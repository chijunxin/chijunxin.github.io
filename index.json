[{"categories":["documentation"],"content":" 1 找到containers 键盘的WIN+R后输入：\\wsl$ 进入docker-desktop 在右侧直接搜索 containers （需要先启动docker-desktop，不然找到的目录是错误的） 这里可能找到多个同名文件夹，右键在新窗口打开，如下图中文件夹名字都是由64个数字和字母组成。 ","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#找到containers"},{"categories":["documentation"],"content":" 2 找到对应的container的Id","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#找到对应的container的id"},{"categories":["documentation"],"content":" 2.1 方法一 通过docker.desktop，在对应容器中查看,图中只显示了Id的一部分，通常对比这部分已经能找到对应的文件夹。 ","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#方法一"},{"categories":["documentation"],"content":" 2.2 方法二 键盘的WIN+R后输入：cmd docker inspect 容器名字 找到其中的Id ","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#方法二"},{"categories":["documentation"],"content":" 3 修改两个配置","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#修改两个配置"},{"categories":["documentation"],"content":" 3.1 进入对应的文件夹 ","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#进入对应的文件夹"},{"categories":["documentation"],"content":" 3.2 config.v2.json“ExposedPorts”: {“8080/tcp”: {},增加需要的端口} ","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#configv2json"},{"categories":["documentation"],"content":" 3.3 hostconfig.json“PortBindings”:{“8080/tcp”:[{“HostIp”:\"\",“HostPort”:“8081”}],增加需要的端口} Tips 建议格式化之后再修改 ","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#hostconfigjson"},{"categories":["documentation"],"content":" 4 重启docker 注意 注意是重启docker，不是重启单个容器","date":"2025-10-11","objectID":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["windows","docker"],"title":"Windows平台docker修改容器的端口映射配置","uri":"/windows%E5%B9%B3%E5%8F%B0docker%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE/#重启docker"},{"categories":["documentation"],"content":" 4 分析自旋锁和互斥锁是用于多线程同步的两种常见锁机制，主要区别在于等待锁的方式和适用场景。以下是它们的对比分析： ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:1:0","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#分析"},{"categories":["documentation"],"content":" 4.1 等待机制 自旋锁（Spinlock） 互斥锁（Mutex） 线程通过 忙等待（Busy-Wait） 持续检查锁状态，不释放CPU。 线程在等待时主动让出CPU，进入阻塞状态，由操作系统调度唤醒。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:1:1","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#等待机制"},{"categories":["documentation"],"content":" 4.2 实现原理 自旋锁（Spinlock） 互斥锁（Mutex） 依赖原子操作（如CAS、Test-And-Set）实现，通常在用户态完成，无需内核介入。 依赖操作系统提供的阻塞/唤醒机制（如信号量、条件变量），涉及内核态切换。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:1:2","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#实现原理"},{"categories":["documentation"],"content":" 4.3 性能特点 自旋锁（Spinlock） 互斥锁（Mutex） 优点：无上下文切换开销，适合锁持有时间极短的场景（如几纳秒）。缺点：长时间等待会浪费CPU资源。 优点：等待时不占用CPU，适合锁持有时间较长或不可预测的场景。 缺点：上下文切换可能带来较大开销。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:1:3","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#性能特点"},{"categories":["documentation"],"content":" 4.4 适用场景 自旋锁（Spinlock） 互斥锁（Mutex） 1. 多核系统，尤其是临界区代码极短（如内核中断处理）。2. 线程不允许休眠的场景（如某些实时系统）。3. 用户态高性能同步（需结合自适应策略）。 1. 用户态应用程序，尤其是临界区代码较复杂或耗时较长（如文件操作）。2. 单核CPU环境。3. 需要避免CPU空转的场景。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:1:4","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#适用场景"},{"categories":["documentation"],"content":" 4.5 其他差异 自旋锁（Spinlock） 互斥锁（Mutex） - 可能导致优先级反转（高优先级线程空转等待低优先级线程）。- 单核系统中需禁用中断或配合调度策略，否则可能死锁。 - 通常支持优先级继承等机制解决优先级反转问题。- 适用于所有CPU架构。 选择建议 用自旋锁：当锁持有时间极短（如计数器操作）且运行在多核环境。 用互斥锁：当锁持有时间较长、不可预测，或需要避免CPU资源浪费时。 通过合理选择锁机制，可以在并发性能和资源利用率之间取得最佳平衡。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:1:5","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#其他差异"},{"categories":["documentation"],"content":" 5 示例","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:0","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#示例"},{"categories":["documentation"],"content":" 5.1 自旋锁（Spinlock）适用场景 多核系统中，临界区代码极短（如计数器操作、状态标志修改）。 内核中断处理程序（线程无法休眠的场景）。 C语言示例（用户态自旋锁） C #include \u003cstdatomic.h\u003e #include \u003cpthread.h\u003e // 自定义自旋锁结构（基于原子操作） typedef struct { atomic_flag flag; } spinlock_t; void spinlock_init(spinlock_t *lock) { atomic_flag_clear(\u0026lock-\u003eflag); } void spinlock_lock(spinlock_t *lock) { // 忙等待直到获取锁 while (atomic_flag_test_and_set(\u0026lock-\u003eflag)) { // 可插入 CPU 自旋优化指令（如 __asm__(\"pause\")） } } void spinlock_unlock(spinlock_t *lock) { atomic_flag_clear(\u0026lock-\u003eflag); } // 使用示例：全局计数器 spinlock_t counter_lock; int counter = 0; void* thread_func(void* arg) { for (int i = 0; i \u003c 100000; i++) { spinlock_lock(\u0026counter_lock); counter++; // 极短的临界区操作 spinlock_unlock(\u0026counter_lock); } return NULL; } int main() { spinlock_init(\u0026counter_lock); pthread_t t1, t2; pthread_create(\u0026t1, NULL, thread_func, NULL); pthread_create(\u0026t2, NULL, thread_func, NULL); pthread_join(t1, NULL); pthread_join(t2, NULL); printf(\"Counter: %d\\n\", counter); // 预期输出 200000 return 0; } ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:1","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#自旋锁spinlock"},{"categories":["documentation"],"content":" 5.2 互斥锁（Mutex）适用场景 用户态应用程序，临界区代码较复杂或耗时（如文件操作、网络请求）。 单核CPU环境，或需要避免CPU空转的场景。 C语言示例（POSIX线程互斥锁） C #include \u003cpthread.h\u003e #include \u003cstdio.h\u003e // 全局互斥锁和共享资源 pthread_mutex_t file_mutex = PTHREAD_MUTEX_INITIALIZER; FILE *shared_file; void* thread_write(void* arg) { const char* data = (const char*)arg; for (int i = 0; i \u003c 100; i++) { pthread_mutex_lock(\u0026file_mutex); // 阻塞等待锁 fprintf(shared_file, \"%s\\n\", data); // 模拟耗时操作 fflush(shared_file); pthread_mutex_unlock(\u0026file_mutex); } return NULL; } int main() { shared_file = fopen(\"output.txt\", \"w\"); pthread_t t1, t2; pthread_create(\u0026t1, NULL, thread_write, \"Thread1\"); pthread_create(\u0026t2, NULL, thread_write, \"Thread2\"); pthread_join(t1, NULL); pthread_join(t2, NULL); fclose(shared_file); return 0; } ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:2","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#互斥锁mutex"},{"categories":["documentation"],"content":" 5.3 关键对比与选择 场景 自旋锁 互斥锁 锁持有时间 纳秒级短操作 毫秒级或更长 CPU占用 高（忙等待） 低（线程休眠） 系统调用开销 无（用户态） 有（内核态） 多核优化 ✔️ 适合 ❌ 一般 单核适用性 ❌ 不适用 ✔️ 适合 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:3","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#关键对比与选择"},{"categories":["documentation"],"content":" 5.4 实际开发中的注意事项 5.4.1 避免自旋锁滥用 用户态程序中优先使用互斥锁，自旋锁仅在内核或极高性能场景使用。 长时间持有自旋锁会导致CPU资源浪费（如死循环）。 5.4.2 互斥锁的高级特性 使用带超时的互斥锁（pthread_mutex_timedlock）避免死锁。 结合条件变量（pthread_cond_wait）实现复杂同步逻辑。 5.4.3 现代语言的封装 C++ 中的 std::mutex 和 std::atomic_flag。 Rust 的 Mutex 和 SpinLock（需注意安全性和生命周期）。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:4","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#实际开发中的注意事项"},{"categories":["documentation"],"content":" 5.4 实际开发中的注意事项 5.4.1 避免自旋锁滥用 用户态程序中优先使用互斥锁，自旋锁仅在内核或极高性能场景使用。 长时间持有自旋锁会导致CPU资源浪费（如死循环）。 5.4.2 互斥锁的高级特性 使用带超时的互斥锁（pthread_mutex_timedlock）避免死锁。 结合条件变量（pthread_cond_wait）实现复杂同步逻辑。 5.4.3 现代语言的封装 C++ 中的 std::mutex 和 std::atomic_flag。 Rust 的 Mutex 和 SpinLock（需注意安全性和生命周期）。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:4","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#避免自旋锁滥用"},{"categories":["documentation"],"content":" 5.4 实际开发中的注意事项 5.4.1 避免自旋锁滥用 用户态程序中优先使用互斥锁，自旋锁仅在内核或极高性能场景使用。 长时间持有自旋锁会导致CPU资源浪费（如死循环）。 5.4.2 互斥锁的高级特性 使用带超时的互斥锁（pthread_mutex_timedlock）避免死锁。 结合条件变量（pthread_cond_wait）实现复杂同步逻辑。 5.4.3 现代语言的封装 C++ 中的 std::mutex 和 std::atomic_flag。 Rust 的 Mutex 和 SpinLock（需注意安全性和生命周期）。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:4","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#互斥锁的高级特性"},{"categories":["documentation"],"content":" 5.4 实际开发中的注意事项 5.4.1 避免自旋锁滥用 用户态程序中优先使用互斥锁，自旋锁仅在内核或极高性能场景使用。 长时间持有自旋锁会导致CPU资源浪费（如死循环）。 5.4.2 互斥锁的高级特性 使用带超时的互斥锁（pthread_mutex_timedlock）避免死锁。 结合条件变量（pthread_cond_wait）实现复杂同步逻辑。 5.4.3 现代语言的封装 C++ 中的 std::mutex 和 std::atomic_flag。 Rust 的 Mutex 和 SpinLock（需注意安全性和生命周期）。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:2:4","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#现代语言的封装"},{"categories":["documentation"],"content":" 6 总结 自旋锁：适合内核、多核短操作，但需严格限制临界区代码长度。 互斥锁：通用性强，适合用户态应用和复杂操作，性能开销可控。 根据实际场景选择锁机制，是高性能并发程序设计的核心技能之一。 ","date":"2025-10-09","objectID":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/:3:0","series":null,"tags":["C"],"title":"自旋锁和互斥锁","uri":"/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81/#总结"},{"categories":["documentation"],"content":" 原文链接：https://manistein.github.io/blog/post/server/skynet/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/ ","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:0:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#"},{"categories":["documentation"],"content":" 13 写在最前面skynet是目前使用比较广泛的服务端框架，虽然目前网上资料众多，但是从自己的学习和使用经历来看，缺乏能够让自己系统了解该框架底层机制的资料，这段时间，趁着自己有时间，阅读了skynet底层的一些代码，现在将自己理解的部分总结并记录下来，以备日后使用。本文旨在捋清skynet框架的结构和主要流程，并不会涉及skynet的方方面面，一些论述，我贴上了一些源码加以论证，并在引用的源码里加入了一些注释。对于一些概念，我也本着严谨的原则，尽可能注明了引证来源的出处，引证自维基百科的内容，基本上是没有争议的词条。由于本人水平有限，如果发现文中内容有错误的地方，或者写的不好的地方，欢迎大家批评指正，最后原创不易，转载请注明出处。 ","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:1:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#写在最前面"},{"categories":["documentation"],"content":" 14 对于skynet，需要屡清楚的几个问题 skynet本质上解决什么问题？ skynet有哪些基本的数据结构？ skynet有几类线程，他们分别的作用是什么？ skynet如何启动一个c服务？ skynet消息调度机制是怎样的？ skynet如何启动一个lua服务？ skynet的lua层消息派发机制是怎样的？ timer是如何产生消息的？他的结构和流程是怎样的？ 网络模块是如何产生消息的？他的结构和流程是怎样的？ skynet有哪些基本服务，他们的作用分别是什么？ skynet集群机制 ","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:2:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#对于skynet需要屡清楚的几个问题"},{"categories":["documentation"],"content":" 15 Overview对于skynet的概述，建议大家先阅读云风大侠的《skynet设计综述》。 skynet本质是什么？它为我们提供了什么机制？如何正确使用它？我们希望自己写的不同的业务逻辑，独立运行在不同的上下文环境中，并且能够通过某种方式，相互协作，最终共同服务于我们的玩家。skynet则为我们提供了这种环境： 我们编写好的c文件，在编译成so库以后，在某个时机，调用该so库api的句柄，会被加载到一个modules列表中，一般这样的模块会被要求定义4种接口create，init，signal和release 我们要创建一个新的，运行该业务逻辑的上下文环境时，则从modules列表中，找到对应的so库句柄，并且调用create接口，创建一个该类业务模块的数据实例，并且创建一个上下文环境（context），引用该类业务的接口和数据实例，该context会被存放在一个统一存放context的列表中，这种context被称之为服务 一个服务，默认不会执行任何逻辑，需要别人向它发出请求时，才会执行对应的逻辑（定时器也是通过消息队列，告诉指定服务，要执行定时事件），并在需要时返回结果给请求者。请求者往往也是其他服务。服务间的请求、响应和推送，并不是直接调用对方的api来执行，而是通过一个消息队列，也就是说，不论是请求、回应还是推送，都需要通过这个消息队列转发到另一个服务中。skynet的消息队列，分为两级，一个全局消息队列，他包含一个头尾指针，分别指向两个隶属于指定服务的次级消息队列。skynet中的每一个服务，都有一个唯一的、专属的次级消息队列。 skynet一共有4种线程，monitor线程用于检测节点内的消息是否堵住，timer线程运行定时器，socket线程进行网络数据的收发，worker线程则负责对消息队列进行调度（worker线程的数量，可以通过配置表指定）。消息调度规则是，每条worker线程，每次从全局消息队列中pop出一个次级消息队列，并从次级消息队列中pop出一条消息，并找到该次级消息队列的所属服务，将消息传给该服务的callback函数，执行指定业务，当逻辑执行完毕时，再将次级消息队列push回全局消息队列中。因为每个服务只有一个次级消息队列，每当一条worker线程，从全局消息队列中pop出一个次级消息队列时，其他线程是拿不到同一个服务，并调用callback函数，因此不用担心一个服务同时在多条线程内消费不同的消息，一个服务执行，不存在并发，线程是安全的 socket线程、timer线程甚至是worker线程，都有可能会往指定服务的次级消息队列中push消息，push函数内有加一个自旋锁，避免同时多条线程同时向一个次级消息队列push消息的惨局。 综上所述，我们可以将skynet的机制，用一张图概括 图1 从上面讨论可以得出如下结论，我们所写的不同的业务逻辑，可以运行在不同的独立的沙盒环境中，他们之间是通过消息队列来进行交互的。worker、timer和socket线程里运行的模块，都有机会向特定的服务push消息，他们是消息的生产者，而worker线程内的模块，同时也是消息的消费者（确切的说，应该是那些服务） 注意：服务模块要将数据，通过socket发送给客户端时，并不是将数据写入消息队列，而是通过管道从worker线程，发送给socket线程，并交由socket转发。此外，设置定时器也不走消息队列，而是直接将在定时器模块，加入一个timer_node。其实这样也很好理解，因为timer和socket线程内运行的模块并不是这里的context，因此消息队列他们无法消费。 在overview中，我们讨论了skynet的部分核心机制（如消息调度），很多细节并未展开仔细去讨论，不过本节的目标就是为了树立一个宏观的概述，后面的内容，将基于此框架更加深入的进行讨论与研究。对于本文，我极力避免贴大段的代码，因为大段的代码，只会让我们迷失在汪洋大海之中，只有在必要的地方，才会贴上代码加以论述。 此外，上面的论述，只涉及到c服务模块，并未讨论lua服务的内容，我们所有的lua服务，均是依附于一个叫snlua的c模块来运行的，lua服务每次收到一个消息，就会产生一个协程（事实上，skynet每个服务均有一个协程池，lua服务收到消息时，会优先去池子里取一个协程出来，这里为了理解方便，就视为收到一个消息，就创建一个协程吧），并通过协程执行注册函数，这些内容会在后面进行讨论。 ","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:3:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#overview"},{"categories":["documentation"],"content":" 16 skynet基本结构1.skynet目录结构 学习一个开源框架，首先要做的就是查看目录结构，我们有理由相信，越好的项目，目录组织越合理，结构越清晰，代码目录必然是按照某种规律进行组织，目录组织也是构架的一部分。skynet目录组织如下所示 图2 从上面目录结构图来看，越是往下的层次，应用领域越广泛。越是往上的层级，针对性越强，应用领域越小，和业务越相关。 3rd目录：提供lua语言支持、 jemalloc（内存管理模块）、md5加密等，这些模块在开发领域有着广泛的应用。 skynet-src目录：包含skynet最核心机制的模块，包括逻辑入口、加载C服务代码的skynet_module模块、运行和管理服务实例的skynet_context模块、skynet消息队列、定时器和socket模块等。 service-src目录：这是依附于skynet核心模块的c服务，如用于日志输出的logger服务，用于运行lua脚本snlua的c服务等。 lualib-src目录：提供C层级的api调用，如调用socket模块的api，调用skynet消息发送，注册回调函数的api，甚至是对C服务的调用等，并导出lua接口，供lua层使用。可以视为lua调C的媒介 service目录：lua层服务，依附于snlua这个c服务，这个目录包含skynet lua层级的一些基本服务，比如启动lua层级服务的bootstrap服务，gate服务，供lua层创建新服务的launcher服务等。 lualib目录：包含调用lua服务的辅助函数，方便应用层调用skynet的一些基本服务；包含对一些c模块或lua模块调用的辅助函数，总之，这些lualib方便应用层调用skynet提供的基本服务，和其他库。 上面的目录基本遵循一个原则，就是上层允许调用下层，而下层不能直接调用上层的api，这样做层次清晰，不会出现你中有我，我中有你的高度耦合的情况存在。c层和lua层耦合的模块则包含在lualib-src中，这种模块划分更利于我们快速寻找对应模块。 基本数据结构 modules管理模块 我们所写的C服务在编译成so库以后，会在某个时机被加载到一个modules的列表中，当要创建该类服务的实例时，将从modules列表取出该服务的函数句柄，调用create函数创建服务实例，并且init之后，将实例赋值给一个新的context对象后，注册到图1所示的skynet_context list中，一个新的服务就创建完成了。我们存放modules的模块数据结构如下所示： C // skynet_module.h typedef void * (*skynet_dl_create)(void); typedef int (*skynet_dl_init)(void * inst, struct skynet_context *, const char * parm); typedef void (*skynet_dl_release)(void * inst); typedef void (*skynet_dl_signal)(void * inst, int signal); struct skynet_module { const char * name; // C服务名称，一般是C服务的文件名 void * module; // 访问该so库的dl句柄，该句柄通过dlopen函数获得 skynet_dl_create create; // 绑定so库中的xxx_create函数，通过dlsym函数实现绑定，调用该create即是调用xxx_create skynet_dl_init init; // 绑定so库中的xxx_init函数，调用该init即是调用xxx_init skynet_dl_release release; // 绑定so库中的xxx_release函数，调用该release即是调用xxx_release skynet_dl_signal signal; // 绑定so库中的xxx_signal函数，调用该signal即是调用xxx_signal }; // skynet_module.c #define MAX_MODULE_TYPE 32 struct modules { int count; // modules的数量 struct spinlock lock; // 自旋锁，避免多个线程同时向skynet_module写入数据，保证线程安全 const char * path; // 由skynet配置表中的cpath指定，一般包含./cservice/?.so路径 struct skynet_module m[MAX_MODULE_TYPE]; // 存放服务模块的数组，最多32类 }; static struct modules * M = NULL; 通过上面的注释，我们大概可以了解skynet_module结构的作用了，也就是说一个符合规范的skynet c服务，应当包含create，init，signal和release四个接口，在该c服务编译成so库以后，在程序中动态加载到skynet_module列表中，这里通过dlopen函数来获取so库的访问句柄，并通过dlsym将so库中对应的函数绑定到函数指针中，对于两个函数的说明如下所示： C // 引证来源：https://linux.die.net/man/3/dlopen void *dlopen(const char *filename, int flag); void *dlsym(void *handle, const char *symbol); dlopen() The function dlopen() loads the dynamic library file named by the null-terminated string filename and returns an opaque \"handle\" for the dynamic library... dlsym() The function dlsym() takes a \"handle\" of a dynamic library returned by dlopen() and the null-terminated symbol name, returning the address where that symbol is loaded into memory... dlopen函数，本质是将so库加载内存中，并返回一个可以访问该内存块的句柄，dlsym，则是通过该句柄和指定一个函数名，到内存中找到指定函数，在内存中的地址，这里将该地址赋值给skynet_module中的create、init、signal或release的其中一个函数指针（根据传入的symbol名称，即函数名来定），一个模块被加载以后，将被放置到modules的skynet_module数组中，当要创建该module的实例时，将会从skynet_module中取出对应的模块，并调用create函数创建实例，然后将实例指针传入init函数完成初始化以后，赋值给context。 一个C服务，定义以上四个接口时，一定要以文件名作为前缀，然后通过下划线和对应函数连接起来，因为skynet加载的时候，就是通过这种方式去寻找对应函数的地址的，比如一个c服务文件名为logger，那么对应的4个函数名则为logger_create、logger_init、logger_signal、logger_release。 skynet_context管理模块 我们创建一个新的服务，首先要先找到对应服务的module，在创建完module实例并完成初始化以后，还需要创建一个skynet_context上下文，并将module实例和module模块和这个context关联起来，最后放置于skynet_context list中，一个个独立的沙盒环境就这样被创建出来了，下面来看主要的数据结构： C // skynet_server.c struct skynet_context { void * instance; // 由指定module的create函数，创建的数据实例指针，同一类服务可能有多个实例， // 因此每个服务都应该有自己的数据 struct skynet_module * mod; // 引用服务module的指针，方便后面对create、init、signal和release函数进行调用 void * cb_ud; // 调用callback函数时，回传给callback的userdata，一般是instance指针 skynet_cb cb; // 服务的消息回调函数，一般在skynet_module的init函数里指定 struct message_queue *queue; // 服务专属的次级消息队列指针 FILE * logfile; // 日志句柄 char result[32]; // 操作skynet_context的返回值，会写到这里 uint32_t handle; // 标识唯一context的服务id int session_id; // 在发出请求后，收到对方的返回消息时，通过session_id来匹配一个返回，对应哪个请求 int ref; // 引用计数变量，当为0时，表示内存可以被释放 bool init; // 是否完成初","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:4:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#skynet基本结构"},{"categories":["documentation"],"content":" 17 skynet如何启动一个c服务我们写的c服务在编译成so库以后，在某个时段，会被加载到modules列表中。创建c服务的工作，一般在c层进行，一般会调用skynet_context_new接口，如下所示： C // skynet_server.c struct skynet_context * skynet_context_new(const char * name, const char *param) { struct skynet_module * mod = skynet_module_query(name); if (mod == NULL) return NULL; void *inst = skynet_module_instance_create(mod); if (inst == NULL) return NULL; struct skynet_context * ctx = skynet_malloc(sizeof(*ctx)); CHECKCALLING_INIT(ctx) ctx-\u003emod = mod; ctx-\u003einstance = inst; ctx-\u003eref = 2; ctx-\u003ecb = NULL; ctx-\u003ecb_ud = NULL; ctx-\u003esession_id = 0; ctx-\u003elogfile = NULL; ctx-\u003einit = false; ctx-\u003eendless = false; // Should set to 0 first to avoid skynet_handle_retireall get an uninitialized handle ctx-\u003ehandle = 0; ctx-\u003ehandle = skynet_handle_register(ctx); struct message_queue * queue = ctx-\u003equeue = skynet_mq_create(ctx-\u003ehandle); // init function maybe use ctx-\u003ehandle, so it must init at last context_inc(); CHECKCALLING_BEGIN(ctx) int r = skynet_module_instance_init(mod, inst, ctx, param); CHECKCALLING_END(ctx) if (r == 0) { struct skynet_context * ret = skynet_context_release(ctx); if (ret) { ctx-\u003einit = true; } skynet_globalmq_push(queue); if (ret) { skynet_error(ret, \"LAUNCH %s %s\", name, param ? param : \"\"); } return ret; } else { skynet_error(ctx, \"FAILED launch %s\", name); uint32_t handle = ctx-\u003ehandle; skynet_context_release(ctx); skynet_handle_retire(handle); struct drop_t d = { handle }; skynet_mq_release(queue, drop_message, \u0026d); return NULL; } } // skynet_module.c struct skynet_module * skynet_module_query(const char * name) { struct skynet_module * result = _query(name); if (result) return result; SPIN_LOCK(M) result = _query(name); // double check if (result == NULL \u0026\u0026 M-\u003ecount \u003c MAX_MODULE_TYPE) { int index = M-\u003ecount; void * dl = _try_open(M,name); if (dl) { M-\u003em[index].name = name; M-\u003em[index].module = dl; if (_open_sym(\u0026M-\u003em[index]) == 0) { M-\u003em[index].name = skynet_strdup(name); M-\u003ecount ++; result = \u0026M-\u003em[index]; } } } SPIN_UNLOCK(M) return result; } static void * _try_open(struct modules *m, const char * name) { const char *l; const char * path = m-\u003epath; size_t path_size = strlen(path); size_t name_size = strlen(name); int sz = path_size + name_size; //search path void * dl = NULL; char tmp[sz]; do { memset(tmp,0,sz); while (*path == ';') path++; if (*path == '\\0') break; l = strchr(path, ';'); if (l == NULL) l = path + strlen(path); int len = l - path; int i; for (i=0;path[i]!='?' \u0026\u0026 i \u003c len ;i++) { tmp[i] = path[i]; } memcpy(tmp+i,name,name_size); if (path[i] == '?') { strncpy(tmp+i+name_size,path+i+1,len - i - 1); } else { fprintf(stderr,\"Invalid C service path\\n\"); exit(1); } dl = dlopen(tmp, RTLD_NOW | RTLD_GLOBAL); path = l; }while(dl == NULL); if (dl == NULL) { fprintf(stderr, \"try open %s failed : %s\\n\",name,dlerror()); } return dl; } _open_sym(struct skynet_module *mod) { size_t name_size = strlen(mod-\u003ename); char tmp[name_size + 9]; // create/init/release/signal , longest name is release (7) memcpy(tmp, mod-\u003ename, name_size); strcpy(tmp+name_size, \"_create\"); mod-\u003ecreate = dlsym(mod-\u003emodule, tmp); strcpy(tmp+name_size, \"_init\"); mod-\u003einit = dlsym(mod-\u003emodule, tmp); strcpy(tmp+name_size, \"_release\"); mod-\u003erelease = dlsym(mod-\u003emodule, tmp); strcpy(tmp+name_size, \"_signal\"); mod-\u003esignal = dlsym(mod-\u003emodule, tmp); return mod-\u003einit == NULL; } 我们要创建一个c服务，首先要获取对应c服务的模块对象，在上一节中，我们已经介绍了skynet的modules对象，它包含skynet_module列表，so库所在路径，创建一个c服务，一般要经历下面几个步骤： 从modules列表中，查找对应的服务模块，如果找到则返回，否则到modules的path中去查找对应的so库，创建一个skynet_module对象（数据结构见上节），将so库加载到内存，并将访问该so库的句柄和skynet_module对象关联（_try_open做了这件事），并将so库中的xxx_create，xxx_init，xxx_signal，xxx_release四个函数地址赋值给skynet_module的create、init、signal和release四个函数中，这样这个skynet_module对象，就能调用so库中，对应的四个接口（_open_sym做了这件事）。 创建一个服务实例即skynet_context对象，他包含一个次级消息队列指针，服务模块指针（skynet_module对象，便于他访问module自定义的create、init、signal和release函数），由服务模块调用create接口创建的数据实例等。 将新创建的服务实例（skynet_context对象）注册到全局的服务列表中（见上节的handle_storage结构）。 初始化服务模块（skynet_module创建的数据实例），并在初始化函数中，注册新创建的skynet_context实例的ca","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:5:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#skynet如何启动一个c服务"},{"categories":["documentation"],"content":" 18 skynet消息调度机制上一节讨论了c服务的创建，现在来讨论消息的派发和消费，本节会讨论skynet的消息派发和消费，以及它如何实现线程安全，要彻底弄清楚这些内容，需要先理解以下四种锁。 互斥锁、自旋锁、读写锁和条件变量 互斥锁（mutex lock : mutual exclusion lock） 概念：互斥锁，一条线程加锁锁住临界区，另一条线程尝试访问改临界区的时候，会发生阻塞，并进入休眠状态。临界区是锁lock和unlock之间的代码片段，一般是多条线程能够共同访问的部分。 具体说明：假设一台机器上的cpu有两个核心core0和core1，现在有线程A、B、C，此时core0运行线程A，core1运行线程B，此时线程B使用Mutex锁，锁住一个临界区，当线程A试图访问该临界区时，因为线程B已经将其锁住，因此线程A被挂起，进入休眠状态，此时core0进行上下文切换，将线程A放入休眠队列中，然后core0运行线程C，当线程B完成临界区的流程并执行解锁之后，线程A又会被唤醒，core0重新运行线程A 引证：维基百科上，Mutual Exclusion词条有一段对互斥锁的解释，一个进程内有两条线程，当一条线程试图访问，被另一条线程锁住的临界区时，那么该线程会阻塞并投入睡眠（suspend） 引证来源：https://en.wikipedia.org/wiki/Mutual_exclusion Software solution这一节 It is often preferable to use synchronization facilities provided by an operating system’s multithreading library, which will take advantage of hardware solutions if possible but will use software solutions if no hardware solutions exist. For example, when the operating system’s lock library is used and a thread tries to acquire an already acquired lock, the operating system could suspend the thread using a context switch and swap it out with another thread that is ready to be run, or could put that processor into a low power state if there is no other thread that can be run. Therefore, most modern mutual exclusion methods attempt to reduce latency and busy-waits by using queuing and context switches. However, if the time that is spent suspending a thread and then restoring it can be proven to be always more than the time that must be waited for a thread to become ready to run after being blocked in a particular situation, then spinlocks are an acceptable solution (for that situation only).[citation needed] 自旋锁（spinlock） 概念：自旋锁，一条线程加锁锁住临界区，另一条线程尝试访问该临界区的时候，会发生阻塞，但是不会进入休眠状态，并且不断轮询该锁，直至原来锁住临界区的线程解锁。 具体说明：假设一台机器上有两个核心core0和core1，现在有线程A、B、C，此时core0运行线程A，core1运行线程B，此时线程B调用spin lock锁住临界区，当线程A尝试访问该临界区时，因为B已经加锁，此时线程A会阻塞，并且不断轮询该锁，不会交出core0的使用权，当线程B释放锁时，A开始执行临界区逻辑 引证：维基百科上，对Spinlock的解释是： 引证来源：https://en.wikipedia.org/wiki/Spinlock In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop (“spin”) while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting. Once acquired, spinlocks will usually be held until they are explicitly released, although in some implementations they may be automatically released if the thread being waited on (that which holds the lock) blocks, or “goes to sleep”. 读写锁（readers–writer lock） 概述：读写锁，一共三种状态 读状态时加锁，此时为共享锁，当一个线程加了读锁时，其他线程如果也尝试以读模式进入临界区，那么不会发生阻塞，直接访问临界区 写状态时加锁，此时为独占锁，当某个线程加了写锁，那么其他线程尝试访问该临界区（不论是读还是写），都会阻塞等待 不加锁 注意: 某线程加读取锁时，允许其他线程以读模式进入，此时如果有一个线程尝试以写模式访问临界区时，该线程会被阻塞，而其后尝试以读方式访问该临界区的线程也会被阻塞 读写锁适合在读远大于写的情形中使用 引证：维基百科对rwlock的解释是： 引证来源：https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock In computer science, a readers–writer (RW) or shared-exclusive lock (also known as a multiple readers/single-writer lock[1] or multi-reader lock[2]) is a synchronization primitive that solves one of the readers–writers problems. An RW lock allows concurrent access for read-only operations, while write operations require exclusive access. This means that multiple threads can read the data in parallel but an exclusive lock is needed for writing or modifying data. When a writer is writing the data, all other writers or readers will be blocked until the writer is finished writing. A common use might be to control access to a data structure in memory that cannot be updated atomically and is invalid (and should not be read by another thread) until the update is complete. Readers–writer locks are usually constructed on top of mutexes and condition variables, or on top of semaphores. 条件变量（condition variables） 概述：假设A,B,C三条线程，其中B,C线程加了cond_wait锁并投入睡眠，而A线程则在某个条件触发时，会通过signal通知B,C线程，从而唤醒B和C线程，更多内容请查阅维基百科，条件变量词条 消费消息流程 概述： skynet在启动时，会创建若干条worker线程（由配置指定），这些worker线程被创建以后，会不断得从global_mq里pop出一个次级消息队列来，每个worker线程，每次只pop一个次级消息队列，然后再从次级消息队列中，pop一到若干条消息出来（受权","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:6:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#skynet消息调度机制"},{"categories":["documentation"],"content":" 19 skynet如何启动一个lua服务每个skynet进程在启动时，都会启动一个lua层的launcher服务，该服务主要负责skynet运作期间，服务的创建工作。我们在lua层创建一个lua层服务时，通常会调用skynet.newservice函数 text -- skynet.lua function skynet.newservice(name, ...) return skynet.call(\".launcher\", \"lua\" , \"LAUNCH\", \"snlua\", name, ...) end -- launcher.lua local function launch_service(service, ...) local param = table.concat({...}, \" \") local inst = skynet.launch(service, param) local response = skynet.response() if inst then services[inst] = service .. \" \" .. param instance[inst] = response else response(false) return end return inst end function command.LAUNCH(_, service, ...) launch_service(service, ...) return NORET end 此时会发送消息给launcher服务，告诉launcher服务，要去创建一个snlua的c服务，并且绑定一个lua_State，该lua_State运行名称为name的lua脚本（这个脚本是入口），这里将c服务名称、脚本名称和参数，拼成一个字符串，并下传给c层 text -- skynet.manager function skynet.launch(...) local addr = c.command(\"LAUNCH\", table.concat({...},\" \")) if addr then return tonumber(\"0x\" .. string.sub(addr , 2)) end end // lua-skynet.c static int _command(lua_State *L) { struct skynet_context * context = lua_touserdata(L, lua_upvalueindex(1)); const char * cmd = luaL_checkstring(L,1); const char * result; const char * parm = NULL; if (lua_gettop(L) == 2) { parm = luaL_checkstring(L,2); } result = skynet_command(context, cmd, parm); if (result) { lua_pushstring(L, result); return 1; } return 0; } // skynet_server.c static const char * cmd_launch(struct skynet_context * context, const char * param) { size_t sz = strlen(param); char tmp[sz+1]; strcpy(tmp,param); char * args = tmp; char * mod = strsep(\u0026args, \" \\t\\r\\n\"); args = strsep(\u0026args, \"\\r\\n\"); struct skynet_context * inst = skynet_context_new(mod,args); if (inst == NULL) { return NULL; } else { id_to_hex(context-\u003eresult, inst-\u003ehandle); return context-\u003eresult; } } 此时，我们就已经创建了一个snlua的c服务（c服务创建流程，上文已经有说明，这里不再赘述），在创建snlua服务的过程中，会对新的snlua服务进行初始化操作 text // service_snlua.c static int _launch(struct skynet_context * context, void *ud, int type, int session, uint32_t source , const void * msg, size_t sz) { assert(type == 0 \u0026\u0026 session == 0); struct snlua *l = ud; skynet_callback(context, NULL, NULL); int err = _init(l, context, msg, sz); if (err) { skynet_command(context, \"EXIT\", NULL); } return 0; } int snlua_init(struct snlua *l, struct skynet_context *ctx, const char * args) { int sz = strlen(args); char * tmp = skynet_malloc(sz); memcpy(tmp, args, sz); skynet_callback(ctx, l , _launch); const char * self = skynet_command(ctx, \"REG\", NULL); uint32_t handle_id = strtoul(self+1, NULL, 16); // it must be first message skynet_send(ctx, 0, handle_id, PTYPE_TAG_DONTCOPY,0, tmp, sz); return 0; } 这里将_launch作为该snlua服务的callback函数，完成注册以后，向自己发送了一个消息，本snlua服务在接收到消息以后，就会调用_launch函数，此时，snlua服务的回调函数会被赋空值，并进行一次snlua绑定的lua_State的初始化 text // service_snlua.c static int _init(struct snlua *l, struct skynet_context *ctx, const char * args, size_t sz) { lua_State *L = l-\u003eL; l-\u003ectx = ctx; lua_gc(L, LUA_GCSTOP, 0); lua_pushboolean(L, 1); /* signal for libraries to ignore env. vars. */ lua_setfield(L, LUA_REGISTRYINDEX, \"LUA_NOENV\"); luaL_openlibs(L); lua_pushlightuserdata(L, ctx); lua_setfield(L, LUA_REGISTRYINDEX, \"skynet_context\"); luaL_requiref(L, \"skynet.codecache\", codecache , 0); lua_pop(L,1); const char *path = optstring(ctx, \"lua_path\",\"./lualib/?.lua;./lualib/?/init.lua\"); lua_pushstring(L, path); lua_setglobal(L, \"LUA_PATH\"); const char *cpath = optstring(ctx, \"lua_cpath\",\"./luaclib/?.so\"); lua_pushstring(L, cpath); lua_setglobal(L, \"LUA_CPATH\"); const char *service = optstring(ctx, \"luaservice\", \"./service/?.lua\"); lua_pushstring(L, service); lua_setglobal(L, \"LUA_SERVICE\"); const char *preload = skynet_command(ctx, \"GETENV\", \"preload\"); lua_pushstring(L, preload); lua_setglobal(L, \"LUA_PRELOAD\"); lua_pushcfunction(L, traceback); assert(lua_gettop(L) == 1); const char * loader = optstring(ctx, \"lualoader\", \"./lualib/loader.lua\"); int r = luaL_loadfile(L,loader); if (r != LUA_OK) { skynet_error(ctx, \"Can't load %s : %s\", loader, lua_tostring(L, -1)); _report_launcher_error","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:7:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#skynet如何启动一个lua服务"},{"categories":["documentation"],"content":" 20 lua层消息处理机制 协程的概念 在讨论lua层的消息处理机制之前，首先要了解一个概念，协程。协程可以视为程序的执行单位，和线程不同，线程是抢占式的，多条线程是并行时运行的，而协程则不是，协程是协同式的，比如有三个协程按顺序先后创建coA、coB、coC，那么在没有任意一条协程主动挂起（yield）的情况下，执行顺序则是coA执行完，在执行coB，然后再执行coC。也就是说，除非有协程主动要求挂起，否则必须等当前协程执行完，再去执行下面一个创建的协程。比如说，coA执行完，接着就是执行coB，此时coB挂起，那么直接执行coC，coC执行完以后，如果coB被唤醒了，则接着上次开始阻塞的部分继续执行余下的逻辑。维基百科对协程的定义如下： 引证来源：https://en.wikipedia.org/wiki/Thread_(computing) 【Processes, kernel threads, user threads, and fibers】这一节 Fibers are an even lighter unit of scheduling which are cooperatively scheduled: a running fiber must explicitly “yield” to allow another fiber to run, which makes their implementation much easier than kernel or user threads. A fiber can be scheduled to run in any thread in the same process. This permits applications to gain performance improvements by managing scheduling themselves, instead of relying on the kernel scheduler (which may not be tuned for the application). Parallel programming environments such as OpenMP typically implement their tasks through fibers. Closely related to fibers are coroutines, with the distinction being that coroutines are a language-level construct, while fibers are a system-level construct. 如上所示，协程和纤程十分相似（纤程是线程下的执行单位），区别在于，纤程是操作系统实现的，而协程是语言本身提供。 协程的使用 这里引用一篇文档加以说明： 引证来源：http://cloudwu.github.io/lua53doc/manual.html#2.6 Lua 支持协程，也叫 协同式多线程。 一个协程在 Lua 中代表了一段独立的执行线程。 然而，与多线程系统中的线程的区别在于， 协程仅在显式调用一个让出（yield）函数时才挂起当前的执行。 调用函数 coroutine.create 可创建一个协程。 其唯一的参数是该协程的主函数。 create 函数只负责新建一个协程并返回其句柄 （一个 thread 类型的对象）； 而不会启动该协程。 调用 coroutine.resume 函数执行一个协程。 第一次调用 coroutine.resume 时，第一个参数应传入 coroutine.create 返回的线程对象，然后协程从其主函数的第一行开始执行。 传递给 coroutine.resume 的其他参数将作为协程主函数的参数传入。 协程启动之后，将一直运行到它终止或 让出。 协程的运行可能被两种方式终止： 正常途径是主函数返回 （显式返回或运行完最后一条指令）； 非正常途径是发生了一个未被捕获的错误。 对于正常结束， coroutine.resume 将返回 true， 并接上协程主函数的返回值。 当错误发生时， coroutine.resume 将返回 false 与错误消息。 通过调用 coroutine.yield 使协程暂停执行，让出执行权。 协程让出时，对应的最近 coroutine.resume 函数会立刻返回，即使该让出操作发生在内嵌函数调用中 （即不在主函数，但在主函数直接或间接调用的函数内部）。 在协程让出的情况下， coroutine.resume 也会返回 true， 并加上传给 coroutine.yield 的参数。 当下次重启同一个协程时， 协程会接着从让出点继续执行。 此时，此前让出点处对 coroutine.yield 的调用 会返回，返回值为传给 coroutine.resume 的第一个参数之外的其他参数。 与 coroutine.create 类似， coroutine.wrap 函数也会创建一个协程。 不同之处在于，它不返回协程本身，而是返回一个函数。 调用这个函数将启动该协程。 传递给该函数的任何参数均当作 coroutine.resume 的额外参数。 coroutine.wrap 返回 coroutine.resume 的所有返回值，除了第一个返回值（布尔型的错误码）。 和 coroutine.resume 不同， coroutine.wrap 不会捕获错误； 而是将任何错误都传播给调用者。 下面的代码展示了一个协程工作的范例： function foo (a) print(\"foo\", a) return coroutine.yield(2*a) end co = coroutine.create(function (a,b) print(\"co-body\", a, b) local r = foo(a+1) print(\"co-body\", r) local r, s = coroutine.yield(a+b, a-b) print(\"co-body\", r, s) return b, \"end\" end) print(\"main\", coroutine.resume(co, 1, 10)) print(\"main\", coroutine.resume(co, \"r\")) print(\"main\", coroutine.resume(co, \"x\", \"y\")) print(\"main\", coroutine.resume(co, \"x\", \"y\")) 当你运行它，将产生下列输出： co-body 1 10 foo 2 main true 4 co-body r main true 11 -9 co-body x y main true 10 end main false cannot resume dead coroutine 你也可以通过 C API 来创建及操作协程： 参见函数 lua_newthread， lua_resume， 以及 lua_yield。 这里对lua协程的代码使用，做了充分的说明，对我们理解lua层消息派发十分有帮助 3. skynet消息处理机制 在前文，我们已经说明了，一个lua服务在接收消息时，最终会传给lua层的消息回调函数skynet.dispatch_message text -- skynet.lua function skynet.dispatch_message(...) local succ, err = pcall(raw_dispatch_message,...) while true do local key,co = next(fork_queue) if co == nil then break end fork_queue[key] = nil local fork_succ, fork_err = pcall(suspend,co,coroutine.resume(co)) if not fork_succ then if succ then succ = false err = tostring(fork_err) else err = tostring(err) .. \"\\n\" .. tostring(fork_err) end end end assert(succ, tostring(err)) end 消息处理函数，只做两件事情，一件是消费当前消息，另一件则是按顺序执行之前通过调用skynet.fork创建的协程，这里我么只关注处理当前消息的情况raw_dispatch_message text -- skynet.lua local function raw_dispatch_message(prototype, msg, sz, session, source, ...) -- skynet.PTYPE_RESPONSE = 1, read skynet.h if prototype == 1 then ... -- 暂不讨论，直接忽略 else local p = proto[prototype] -- 找到与消息类型对应的解析协议 if p == nil then if session ~= 0 then c.send(source, skynet.PTYPE_ERROR, session, \"\") else un","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:8:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#lua层消息处理机制"},{"categories":["documentation"],"content":" 21 timer的运作机制我们使用定时器的两种情况，一种是设置一个定时器，让某个函数在t秒后执行；还有一种则是，在执行某个函数的过程中，暂停t秒后继续执行。 第一种情况，我们使用skynet.timeout来执行： text -- skynet.lua function skynet.timeout(ti, func) local session = c.intcommand(\"TIMEOUT\",ti) assert(session) local co = co_create(func) assert(session_id_coroutine[session] == nil) session_id_coroutine[session] = co end 这里，首先向定时器注册了一个事件，这个事件的信息包含服务地址、多少秒后触发定时事件以及一个session变量；然后为执行函数创建一个协程，协程创建后默认不执行，因此目前的func相当于冻结状态，最后lua层会以session为key，协程地址为value存入一个table表中。当该事件的触发时间到的时候，timer线程会取出时间数据，向事件所属的地址发送一条RESPONSE类型的消息 text // skynet_timer.c static inline void dispatch_list(struct timer_node *current) { do { struct timer_event * event = (struct timer_event *)(current+1); struct skynet_message message; message.source = 0; message.session = event-\u003esession; message.data = NULL; message.sz = (size_t)PTYPE_RESPONSE \u003c\u003c MESSAGE_TYPE_SHIFT; skynet_context_push(event-\u003ehandle, \u0026message); struct timer_node * temp = current; current=current-\u003enext; skynet_free(temp); } while (current); } 服务收到这个消息以后，会根据session的值，找回协程地址，并调用resume函数，唤醒这个协程，这样就完成了t秒后执行某个函数的功能。 第二种情况，我们使用skynet.sleep来执行 text -- skynet.lua function skynet.sleep(ti) local session = c.intcommand(\"TIMEOUT\",ti) assert(session) local succ, ret = coroutine_yield(\"SLEEP\", session) sleep_session[coroutine.running()] = nil if succ then return end if ret == \"BREAK\" then return \"BREAK\" else error(ret) end end 一个协程内的函数，在执行的过程中，调用了sleep函数以后，此时首先会向定时器注册一个事件，这个时间包含了服务地址、睡眠时间ti和一个session变量，然后就对当前协程执行挂起操作，挂起类型为SLEEP，此时会触发对suspend函数的调用，前面已经讨论过，suspend函数对SLEEP这种挂起类型的处理是，以session为key，再以协程地址为value存入一个table中（详见 lua层消息处理机制 一节）。在ti秒以后，timer线程触发定时事件，并向服务发送一个RESPONSE类型的消息，服务收到消息以后会调用resume唤醒该协程，从而使该协程继续执行后面的逻辑。 本节讨论了定时器最常见的两种使用情况，并且讨论了timer线程如何和worker线程内的服务进行交互，本节为了突出问题关键，并未对timer内部的运作细节进行一一讨论，但是这些事没有必要的，我们只要知道timer事件如何添加，timer何时会通知服务，如何通知即可，无需在一些复杂的细节里耗费太多的时间和精力。 ","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:9:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#timer的运作机制"},{"categories":["documentation"],"content":" 22 网络层运作机制对于网络层，本质上是对socket线程的运作流程进行讨论，本节的主要目标是弄清以下几个问题： skynet网络层的初始化流程是怎样的？ skynet网络层是如何绑定和监听一个端口的？ skynet网络层，建立一个连接的流程是怎样的？ 客户端发送的数据包，是怎样转发到指定的服务上的？ 服务端不同服务的数据包，发送到客户端的流程是怎样的？ 捋清了上面几点，基本上就捋清了skynet网络层的运作流程，这里不讨论所有的通信细节，只是对主流程进行讨论，虽然skynet包含epoll模型和kqueue，这里只对epoll进行讨论。 skynet网络层基本数据结构 在开始讨论具体的流程之前，首先我们要讨论一下socket部分的主要数据结构 text // socket_server.c struct socket { uintptr_t opaque; // 与本socket关联的服务地址，socket接收到的消息，最后将会传送到这个服务商 struct wb_list high; // 高优先级发送队列 struct wb_list low; // 低优先级发送队列 int64_t wb_size; // 发送字节大小 int fd; // socket文件描述符 int id; // 位于socket_server的slot列表中的位置 uint16_t protocol; // 使用的协议tcp or udp uint16_t type; // epoll事件触发时，会根据type来选择处理事件的逻辑 union { int size; uint8_t udp_address[UDP_ADDRESS_SIZE]; } p; }; struct socket_server { int recvctrl_fd; // 接收管道消息的文件描述 int sendctrl_fd; // 发送管道消息的文件描述 int checkctrl; // 判断是否有其他线程通过管道，向socket线程发送消息的标记变量 poll_fd event_fd; // epoll实例id int alloc_id; // 已经分配的socket slot列表id int event_n; // 标记本次epoll事件的数量 int event_index; // 下一个未处理的epoll事件索引 struct socket_object_interface soi; struct event ev[MAX_EVENT]; // epoll事件列表 struct socket slot[MAX_SOCKET]; // socket 列表 char buffer[MAX_INFO]; // 地址信息转成字符串以后，存在这里 uint8_t udpbuffer[MAX_UDP_PACKAGE]; fd_set rfds; }; 上面两个，估计是socket模块中最重要的两个结构了，注释里对多数字段，进行了说明，这里首先要谈谈socket_server这个结构，首先skynet的其他线程，向socket线程发送消息，是通过管道来进行的，也就是说，如果worker线程往sendctrl_fd写入数据，那么在socket线程，只需要对recvctrl_fd进行读取，就能收到worker线程发送过来的数据包，这么做的好处，则是使这一流程变得非常简单，而且保证线程安全。checkctrl则用来标记是否有其他线程向socket线程发送管道消息，如果有则被置为1。 每次有epoll事件触发时，都会往epoll事件列表ev中写入，并返回事件的数量，每处理完一个事件，event_index就会增加一（每次epoll事件触发时，event_index都会被重置为0）。 socket_server结构中，有一个socket列表–slot列表，这里存放的都是socket对象实例，slot列表和epoll事件关联度非常大，每当一个连接建立时，该连接的fd会增加一个epoll事件，我们来看看如何为fd增加一个epoll可读事件 text // socket_server.c static struct socket * new_fd(struct socket_server *ss, int id, int fd, int protocol, uintptr_t opaque, bool add) { struct socket * s = \u0026ss-\u003eslot[HASH_ID(id)]; assert(s-\u003etype == SOCKET_TYPE_RESERVE); if (add) { if (sp_add(ss-\u003eevent_fd, fd, s)) { s-\u003etype = SOCKET_TYPE_INVALID; return NULL; } } s-\u003eid = id; s-\u003efd = fd; s-\u003eprotocol = protocol; s-\u003ep.size = MIN_READ_BUFFER; s-\u003eopaque = opaque; s-\u003ewb_size = 0; check_wb_list(\u0026s-\u003ehigh); check_wb_list(\u0026s-\u003elow); return s; } // socket_epoll.h static int sp_add(int efd, int sock, void *ud) { struct epoll_event ev; ev.events = EPOLLIN; ev.data.ptr = ud; if (epoll_ctl(efd, EPOLL_CTL_ADD, sock, \u0026ev) == -1) { return 1; } return 0; } 这里我们可以看到，要让epoll监听fd，当这个fd有事件时，epoll会返回事件，但是epoll不会告诉你，怎么去处理这个事件，因此，需要根据socket的type来选择正确的处理逻辑（这里需要注意的是，epoll事件的data的ptr指针，指向一个socket结构的指针） text // return type int socket_server_poll(struct socket_server *ss, struct socket_message * result, int * more) { for (;;) { ... if (ss-\u003eevent_index == ss-\u003eevent_n) { ss-\u003eevent_n = sp_wait(ss-\u003eevent_fd, ss-\u003eev, MAX_EVENT); ss-\u003echeckctrl = 1; if (more) { *more = 0; } ss-\u003eevent_index = 0; if (ss-\u003eevent_n \u003c= 0) { ss-\u003eevent_n = 0; return -1; } } struct event *e = \u0026ss-\u003eev[ss-\u003eevent_index++]; struct socket *s = e-\u003es; if (s == NULL) { // dispatch pipe message at beginning continue; } switch (s-\u003etype) { case SOCKET_TYPE_CONNECTING: return report_connect(ss, s, result); case SOCKET_TYPE_LISTEN: if (report_accept(ss, s, result)) { return SOCKET_ACCEPT; } break; case SOCKET_TYPE_INVALID: fprintf(stderr, \"socket-server: invalid socket\\n\"); break; default: ... } } } epoll事件触发以后，最终是根据ud的信息，来进行对应的逻辑处理的，而这里的ud则是socket变量，也就是说slot列表里的socket对象，是和epoll最为相关的。 skynet网络层的初始化流程 在启动一个skynet节点的时候，首先会对socket模块进行初始化： text // skynet_socket.c static struct socket_server * SOCKET_SERVER = NULL; void skynet_socket_init() { SOCKET_SERVER = socket_server_create(); } // socket_server.c struct socket_server * socket_server_create() { int i; int fd[2]; poll_fd efd = sp_create(); if (sp_invalid(efd)) { fprintf(stderr, \"socket-server: create event pool failed.\\n\"); return NULL; } // 创建管道，用于其他线程向socket线程发送消息，这样能够轻松保证其他线程向socket线程发送数据包时的线程安全 if (pipe(fd)) { sp_release(efd); fprintf(stderr, \"socket-server: create socket pair failed.\\n\"); return NULL; } if (","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:10:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#网络层运作机制"},{"categories":["documentation"],"content":" 23 skynet的几个基本服务我们可以在skynet/service/bootstrap.lua里看到skynet的基本lua服务启动流程，这里不再赘述。 ","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:11:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#skynet的几个基本服务"},{"categories":["documentation"],"content":" 24 集群这一部分，云风大侠已经说的很清楚了，这里就不敢班门弄斧。 如何使用查看Cluster Cluster设计请查看skynet cluster 模块的设计与编码协议 原文链接：https://manistein.github.io/blog/post/server/skynet/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/ ","date":"2025-10-09","objectID":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/:12:0","series":null,"tags":["skynet"],"title":"Skynet源码赏析","uri":"/skynet%E6%BA%90%E7%A0%81%E8%B5%8F%E6%9E%90/#集群"},{"categories":["documentation"],"content":" 1 为什么选择用源码版 由于官方的二进制版本是无法发布专用服务器（Dedicated Server）的。 项目需要修改了源码的内容 建议 如果不是出于以上任何一个原因都不推荐用源码版。二进制版本直接开箱即用多香。 ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:1:0","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#为什么选择用源码版"},{"categories":["documentation"],"content":" 2 源码下载官方源码下载教程： 从GitHub下载虚幻引擎源代码 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/downloading-source-code-in-unreal-engine 虚幻GitHub仓库： GitHub: EpicGames/UnrealEngine https://github.com/EpicGames/UnrealEngine ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:2:0","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#源码下载"},{"categories":["documentation"],"content":" 3 环境配置 注意 一定要根据当前源码版的SDK配置要求来安装本地环境！！！ 一定要根据当前源码版的SDK配置要求来安装本地环境！！！ 一定要根据当前源码版的SDK配置要求来安装本地环境！！！ 主要还是要保证SDK版本一致，有时候最新的会导致编译报错，修改了相关的SDK版本后，需要重新生成.sln文件，然后再编译。 每个大版本发布的时候，虚幻官网都有对应的版本说明，找到对应版本的SDK要求，按照要求去下载，每个版本都不一样！！！ 下面是虚幻5.4的版本说明：《平台sdk升级》中有详细的SDK要求 虚幻文档：虚幻引擎5.4版本说明 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-5.4-release-notes?application_version=5.4#%E5%B9%B3%E5%8F%B0sdk%E5%8D%87%E7%BA%A7 所以我的本地编译版本的详细信息如下： Visual Studio 2022 - v17.4 (可以根据实际情况选择更高的) MSVC - 14.38.33130 (可以根据实际情况选择更高的) Windows SDK - 10.0.18362 (可以根据实际情况选择更高的) LLVM clang - 16.0.6 .NET 4.6.2 Targeting Pack (定死了的版本) .NET 6.0 (定死了的版本) 建议 MSVC和SDK的版本我建议按官网的推荐版本就可以了，不要用更高版本的，不要问为什么 虚幻文档：设置Visual Studio https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:3:0","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#环境配置"},{"categories":["documentation"],"content":" 4 下载引擎依赖文件以管理员身份运行引擎目录下的Setup.bat进行依赖的下载 时间相当长，有20G多的内容，而且国内下着下着就断开了，如果断开了就再次运行Setup.bat就可以，支持断点续传，不用全部重新下载。 ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:4:0","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#下载引擎依赖文件"},{"categories":["documentation"],"content":" 5 生成对应的工程文件确认所有依赖下载完之后，以管理员身份运行引擎目录下的GenerateProjectFiles.bat ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:5:0","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#生成对应的工程文件"},{"categories":["documentation"],"content":" 6 官方参考剩下的内容参考虚幻官方的教程即可，参考链接： 虚幻文档：从源代码构建虚幻引擎 https://dev.epicgames.com/documentation/zh-cn/unreal-engine/building-unreal-engine-from-source ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:6:0","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#官方参考"},{"categories":["documentation"],"content":" 7 用源码版本遇到的问题部分问题是从网友处摘抄 ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:7:0","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#用源码版本遇到的问题"},{"categories":["documentation"],"content":" 7.1 编译完成时遇到1 失败，其他都成功了用VS2022重新生成项目每次完成时都会遇到 11 成功，1 失败。再次点生成就又能正常编译通过。暂时没找到是什么原因导致的 ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:7:1","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#编译完成时遇到1-失败其他都成功了"},{"categories":["documentation"],"content":" 7.2 编译时遇到 error C4756: 常量算法中溢出UE默认应该用的是你安装过的最新的MSVC来做的编译，这有可能超过了该版本UE指定的MSVC。这个可以通过正确设置MSVC版本来解决。以UE5.4为例,应该使用 14.38.33130 版本的MSVC。 通过修改BuildConfiguration.xml来配置 提示 通常在以下两个路径 引擎所在目录/Engine/Saved/UnrealBuildTool %appdata%/Unreal Engine/UnrealBuildTool BuildConfiguration.xml \u003c?xml version=\"1.0\" encoding=\"utf-8\" ?\u003e \u003cConfiguration xmlns=\"https://www.unrealengine.com/BuildConfiguration\"\u003e \u003cWindowsPlatform\u003e \u003cCompilerVersion\u003e14.38.33130\u003c/CompilerVersion\u003e \u003cWindowsSdkVersion\u003e10.0.22621.0\u003c/WindowsSdkVersion\u003e \u003c/WindowsPlatform\u003e \u003c/Configuration\u003e 以下链接可查看UE5推荐的MSVC版本 虚幻文档：设置Visual Studio https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine 参考于以下文章： UE5:为特定版本引擎指定MSVC版本的方法 [友链页](https://zhuanlan.zhihu.com/p/6959954923) ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:7:2","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#编译时遇到-error-c4756-常量算法中溢出"},{"categories":["documentation"],"content":" 7.3 编译时遇到 error C1001: 内部编译器错误。","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:7:3","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#编译时遇到-error-c1001-内部编译器错误"},{"categories":["documentation"],"content":" 7.4 奇怪的引擎版本名称位于项目的XX.uproject文件里面 \"EngineAssociation\": \"5.4\", 版本会变成一串长字符串 源码版 二进制版 EngineAssociation的值其实指向的是当前的引擎路径，这个路径可在注册表中找到 计算机\\HKEY_CURRENT_USER\\Software\\Epic Games\\Unreal Engine\\Builds 那么这个值不一样会导致哪些问题呢？ 项目文件混乱： 如果你用一个源码编译的引擎打开一个之前用官方5.3版本创建的项目，引擎会提示“项目是由其他版本的引擎创建的，是否要转换？”。如果你选择“是”，它会将项目的 EngineAssociation 更新为你编译引擎的GUID。 此后，这个项目在Epic启动器中可能无法正确识别或打开，因为启动器不认识你这个自定义的GUID。 团队协作问题： 如果团队中有人用官方二进制版本，有人用源码编译版本，那么 .uproject 文件中的 EngineAssociation 会频繁被不同的人修改，导致版本控制上的冲突和混乱。 ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:7:4","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#奇怪的引擎版本名称"},{"categories":["documentation"],"content":" 7.5 警告：文件保存自空版本引擎这个每次启动项目的时候都会提示，通常出现在源码版跟二进制版本混用的情况 ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:7:5","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#警告文件保存自空版本引擎"},{"categories":["documentation"],"content":" 7.6 不定期出现需要重新编译引擎/插件代码的情况 B站专栏：定制UE4引擎，如何避免C++项目重编引擎 https://www.bilibili.com/opus/464162093554185164/?from=readlist ","date":"2025-10-02","objectID":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/:7:6","series":null,"tags":["虚幻"],"title":"源码安装UE5","uri":"/%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85ue5/#不定期出现需要重新编译引擎插件代码的情况"},{"categories":["documentation"],"content":" 1 核心概念在 Skynet 中，无论是 Lua 服务还是 C 服务，本质上都是一个 skynet 模块（module）。这个模块是一个动态链接库（在 Linux 上是 .so 文件，在 macOS 上是 .dylib 文件，在 Windows 上是 .dll 文件）。 ","date":"2025-09-30","objectID":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/:1:0","series":null,"tags":["skynet"],"title":"Skynet如何创建和启动的c服务","uri":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/#核心概念"},{"categories":["documentation"],"content":" 2 编写 C 服务模块C 服务模块必须实现并导出几个特定的函数供 Skynet 框架调用。 xxx_create： 创建服务实例。 xxx_init： 初始化服务实例。 xxx_release： 释放服务实例（可选）。 xxx_signal： 处理信号（可选）。 service_simple.c // service_simple.c #include \"skynet.h\" // 必须包含 Skynet 头文件 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e // 定义服务的数据结构 struct simple { int number; // 示例：一个简单的成员变量 }; // 1. 创建函数 (simple_create) // 当 Skynet 启动该服务时，首先调用此函数来创建服务对象。 struct simple * simple_create(void) { struct simple * s = skynet_malloc(sizeof(*s)); // 使用 Skynet 的内存管理函数 s-\u003enumber = 0; return s; } // 消息处理回调函数 static int simple_callback(struct skynet_context *ctx, void *ud, int type, int session, uint32_t source, const void *msg, size_t sz) { struct simple *s = ud; s-\u003enumber++; skynet_error(ctx, \"[simple] Received message number:%d\", s-\u003enumber); switch (type) { case PTYPE_TEXT: { // 处理文本消息 skynet_error(ctx, \"[simple] Received text: %.*s\", (int)sz, (const char *)msg); // 回显消息 skynet_send(ctx, 0, source, PTYPE_RESPONSE, session, (void *)msg, sz); break; } case PTYPE_RESERVED_LUA: { // 处理 Lua 消息 skynet_error(ctx, \"[simple] Received lua: %s\", (const char *)msg); break; } case PTYPE_RESPONSE: { skynet_error(ctx, \"[simple] Received response\"); break; } default: { skynet_error(ctx, \"[simple] Unknown message type: %d\", type); break; } } return 0; } // 2. 初始化函数 (simple_init) // 创建成功后，Skynet 会调用此函数进行初始化。 // ctx: 该服务的上下文指针，非常重要，用于发送消息、注册回调等。 // context: 启动服务时传入的参数（字符串形式）。 int simple_init(struct simple * s, struct skynet_context * ctx, const char * context) { printf(\"Simple Service Init: %s\\n\", context); // 示例：解析启动参数 if (context != NULL) { s-\u003enumber = atoi(context); } // 这里可以注册消息回调函数(非必要) skynet_callback(ctx, s, simple_callback); return 0; // 返回 0 表示初始化成功 } // 3. 释放函数 (simple_release) // 当服务被退出时，Skynet 会调用此函数来释放资源。 void simple_release(struct simple * s) { printf(\"Simple Service Release, number = %d\\n\", s-\u003enumber); skynet_free(s); // 释放内存 } ","date":"2025-09-30","objectID":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/:2:0","series":null,"tags":["skynet"],"title":"Skynet如何创建和启动的c服务","uri":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/#编写-c-服务模块"},{"categories":["documentation"],"content":" 3 编译成动态链接库你需要编写一个 Makefile，将你的 C 代码编译成 Skynet 可以加载的 .so 文件。 makefile # Makefile # 设置 Skynet 的根目录路径。 SKYNET_PATH ?= ../../skynet-1.8.0 SKYNET_LUA_PATH ?= $(SKYNET_PATH)/3rd/lua SKYNET_CSERVICE_PATH ?= $(SKYNET_PATH)/cservice # 包含 Skynet 的编译配置 include $(SKYNET_PATH)/platform.mk # 设置需要的额外编译参数 # MYCFLAGS = CFLAGS = -g -O2 -Wall -I$(SKYNET_LUA_PATH) $(MYCFLAGS) # 你的服务名，通常和你的 C 文件名一致。 CSERVICE = simple define CSERVICE_TEMP $$(SKYNET_CSERVICE_PATH)/$(1).so : ./service_$(1).c | $$(SKYNET_CSERVICE_PATH) $$(CC) $$(CFLAGS) $$(SHARED) $$\u003c -o $$@ -I$(SKYNET_PATH)/skynet-src endef $(foreach v, $(CSERVICE), $(eval $(call CSERVICE_TEMP,$(v)))) all : \\ $(foreach v, $(CSERVICE), $(SKYNET_CSERVICE_PATH)/$(v).so) $(SKYNET_CSERVICE_PATH) : mkdir -p $(SKYNET_CSERVICE_PATH) 然后在终端执行： bash make linux 确保最终生成的.so文件路径已配置在 cpath 中 ","date":"2025-09-30","objectID":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/:3:0","series":null,"tags":["skynet"],"title":"Skynet如何创建和启动的c服务","uri":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/#编译成动态链接库"},{"categories":["documentation"],"content":" 4 在 Lua 中启动 C 服务通常我们使用 skynet.newservice 启动lua服务，但我们无法直接使用 · 启动一个C服务，我们需要使用 skynet.call(\".launcher\", \"lua\" , \"LAUNCH\", \"服务名\") 启动C服务。当然也可以直接使用 skynet.launch(\"服务名\")，但是这会跳过 launcher 服务的服务管理（不建议）。 lua skynet.call(\".launcher\", \"lua\" , \"LAUNCH\", \"simple\") ","date":"2025-09-30","objectID":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/:4:0","series":null,"tags":["skynet"],"title":"Skynet如何创建和启动的c服务","uri":"/skynet%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%9A%84c%E6%9C%8D%E5%8A%A1/#在-lua-中启动-c-服务"},{"categories":["documentation"],"content":"在 Skynet 框架中，选择使用 C 语言还是 Lua 语言编写服务需要根据具体场景来决定。以下是建议使用 C 语言编写 Skynet 服务的情况： 1.高性能计算密集型任务（数学计算、加密解密、数据压缩等） 2.底层系统操作（文件 I/O、网络套接字、设备操作等；skynet提供的logger就是通过C服务编写的） 3.与现有C/C++库集成(kafka的C库、音视频编解码库FFmpeg、图像处理库OpenCV等) 4.协议解析和序列化(自定义二进制协议、Protobuf/FlatBuffers处理、实时数据流解析等) ","date":"2025-09-30","objectID":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/:0:0","series":null,"tags":["skynet"],"title":"Skynet服务开发语言选择指南","uri":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/#"},{"categories":["documentation"],"content":" 4 📊决策矩阵 场景 推荐语言 理由 业务逻辑 Lua 开发效率高，热更新方便 高性能计算 C 执行效率高，硬件控制强 系统底层操作 C 直接系统调用，无额外开销 内存敏感 C 精细内存控制，避免GC 第三方库集成 C 直接调用，无绑定层开销 协议解析 C 处理速度快，内存效率高 ","date":"2025-09-30","objectID":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/:1:0","series":null,"tags":["skynet"],"title":"Skynet服务开发语言选择指南","uri":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/#决策矩阵"},{"categories":["documentation"],"content":" 5 📈性能对比考虑 指标 C 语言 Lua 语言 执行速度 ⭐⭐⭐⭐⭐ ⭐⭐ 开发效率 ⭐⭐ ⭐⭐⭐⭐⭐ 内存控制 ⭐⭐⭐⭐⭐ ⭐⭐ 热更新 ⭐ ⭐⭐⭐⭐⭐ 系统集成 ⭐⭐⭐⭐⭐ ⭐⭐ ","date":"2025-09-30","objectID":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/:2:0","series":null,"tags":["skynet"],"title":"Skynet服务开发语言选择指南","uri":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/#性能对比考虑"},{"categories":["documentation"],"content":" 6 🎯 总结建议","date":"2025-09-30","objectID":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/:3:0","series":null,"tags":["skynet"],"title":"Skynet服务开发语言选择指南","uri":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/#-总结建议"},{"categories":["documentation"],"content":" 6.1 使用 C 语言当： 性能是首要考虑因素 需要直接操作系统资源 集成现有 C/C++ 生态 处理大量二进制数据 对内存使用有严格要求 ","date":"2025-09-30","objectID":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/:3:1","series":null,"tags":["skynet"],"title":"Skynet服务开发语言选择指南","uri":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/#使用-c-语言当"},{"categories":["documentation"],"content":" 6.2 使用 Lua 语言当： 开发速度更重要 需要频繁修改和热更新 业务逻辑复杂多变 团队 Lua 技能更熟练 性能要求不是极端严格 ","date":"2025-09-30","objectID":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/:3:2","series":null,"tags":["skynet"],"title":"Skynet服务开发语言选择指南","uri":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/#使用-lua-语言当"},{"categories":["documentation"],"content":" 6.3 混合开发建议(C + Lua 混合模式)在实际项目中，通常采用混合架构：用 C 实现底层基础设施和性能关键组件，用 Lua 实现业务逻辑和上层应用。 例如常用json库就是通过C语言编写成lua模块(这类模块在linux中一般以.so结尾)。 json.decode、json.encode这类接口都属于主动调用的场景使用的。但有时我们不得不被动调用某些接口，如使用了某些第三方C库，需要绑定回调时，这时我们无法直接去唤醒服务来调用函数(这会打断skynet的底层调度)。 这里提供了2个方案解决这类问题： 在C回调中把需要用到的数据用C缓存起来，在lua服务中定时消费掉缓存数据。 在C回调中直接将消息加入服务队列，这需要维护好skynet的服务地址。 ","date":"2025-09-30","objectID":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/:3:3","series":null,"tags":["skynet"],"title":"Skynet服务开发语言选择指南","uri":"/skynet%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97/#混合开发建议c--lua-混合模式"},{"categories":["documentation"],"content":"Linux服务器TCP连接数到底有多少？ 在网络开发的世界里，一个基础但常常被误解的问题是：一台Linux服务器到底能支持多少个TCP连接？🤔 很多人第一反应是65535，因为“听说端口号有这么多，那长连接也应该有这么多吧？” 但真的是这样吗？ 要搞清楚这个问题，关键在于理解TCP连接的两端——客户端和服务器端。🔍 任何一台服务器，实际上既是服务器端，也是客户端。例如，对于你的后端接口来说，用户是客户端，但当你请求Redis或MySQL时，你又变成了客户端。 如果你不把服务器端的角色和客户端的角色分开来理解，这个问题会一直困扰你。😵 因此，我们需要从客户端和服务端两个方面来探讨。 🌐 从客户端的角度看，一个Linux机器作为客户端时，理论上可以建立无数个连接，只要资源充足。 🔧 从服务端的角度看，问题就复杂多了。服务端需要维护一个连接状态，如果连接数过多，可能会耗尽系统资源，导致性能下降甚至崩溃。因此，服务端的连接数通常受到系统资源和管理策略的限制。 💡 总结来说，一台Linux服务器能支持多少TCP连接，并不是一个简单的数字问题，而是需要综合考虑客户端和服务端的角色、系统资源和管理策略。在实际开发中，合理管理和优化连接数是提高系统性能和可靠性的关键。 ","date":"2025-09-30","objectID":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/:0:0","series":null,"tags":["网络","linux"],"title":"一台linux最大能支持多少条TCP连接","uri":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/#"},{"categories":["documentation"],"content":" 1 一台linux服务器最大能打开的文件数","date":"2025-09-30","objectID":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/:1:0","series":null,"tags":["网络","linux"],"title":"一台linux最大能支持多少条TCP连接","uri":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/#一台linux服务器最大能打开的文件数"},{"categories":["documentation"],"content":" 1.1 限制参数我们知道在Linux中一切皆文件,那么一台服务器最大能打开多少个文件呢? Linux上能打开的最大文件数量受三个参数影响,分别是: ·fs.file-max(系统级别参数):该参数描述了整个系统可以打开的最大文件数量。但是root用户不会受该参数限制(比如:现在整个系统打开的文化牛描述符数量已达到fs.file-max,此时root用户仍然可以使用ps、kill等命令或打开其其他文件描述符)。 soft nofile(进程级别参数):限制单个进程上可以打开白的最大文件数。只能在Linux上配置一次,不能针对不同用户配置不同的值。 fs.nr_open(进程级别参数):限制单个进程上可以打开的最大文件数。可以针对不同用户配置不同的值。 ","date":"2025-09-30","objectID":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/:1:1","series":null,"tags":["网络","linux"],"title":"一台linux最大能支持多少条TCP连接","uri":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/#限制参数"},{"categories":["documentation"],"content":" 1.2 调整服务器能打开的最大文件数示例假设想让进程可以打开100万个文件描述符,这里用修改conf文件的方式给出一个建议。 如果日后工作里有类似的需求可以作为参考。 bash vim/etc/sysctl.conf fs.file-max=1100000//系统级别设置成110万,多留点buffer fs.nr open=110000//进程级别也设置成110万,因为要保证比hard nofile大 使上面的配置生效sysctl -p bash vim/etc/security/limits.conf //用户进程级别都设置成100万 soft nofile 1000000 hard nofile 1000000 ","date":"2025-09-30","objectID":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/:1:2","series":null,"tags":["网络","linux"],"title":"一台linux最大能支持多少条TCP连接","uri":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/#调整服务器能打开的最大文件数示例"},{"categories":["documentation"],"content":" 2 一台服务器最大能支持多少连接我们知道TCP连接,从根本上看其实就是client和serve端在内存中维护的一组 【socket内核对象】(这里也对应着TCP四元组:源IP、源端口口、目标IP、目标端口) 他们只要能够找到对方,那么就算是一条连接。那么一台服务器最大能建立多少条连接 呢? 由于TCP连接本质上可以理解为是client-server端的一对socket内核对象,那么从理论 上将应该是【 2^32(ip数)*2^16(端口数) 】条连接(约等于两百多万亿)。 但是实际上由于受其他软硬件的影响,我们一台服务器不可能能建立这么多连接(主 要是受CPU和内存限制) 如果只以ESTABLISH状态的连接来算(这些连接只是建立,但是不收发数据也不处理相关 的业务逻辑)那么一台服务器最大能建立多少连接呢?以一台4GB内存的服务器为例! 这种情况下,那么能建立的连接数量主要取决于【 内存的大小 】(因为如果是) ESTABLISH状态的空闲连接,不会消耗CPU(虽然有TCP保活包传输,但这个影响非 常小,可以忽略不计)。 我们知道一条ESTABLISH状态的连接大约消耗【 3.3KBI内存 】,那么通过计算得知一台 4GB内存的服务器,【 可以建立100w+的TCP连接 】(当然这里只是计算所有的连接 都只建立连接但不发送和处理数据的情况,如果真实场景中有数据往来和处理(数据 接收和发送都需要申请内存,数据处理便需要CPU),那便会消耗更高的内存以及占 用更多的CPU,并发不可能达到100w+)。 上面讨论的都是建立连接的理想情况,在现实中如果有频繁的数据收发和处理(比如: 压缩、加密等),那么一台服务器能支撑1000连接都算好的了,所以一台服务器能支撑多 少连接还要结合具体的场景去分析,不能光靠理论值去算。抛开业务逻辑单纯的谈并发没 有太大的实际意义。 服务器的开销大头往往并不是连接本身,而是每条连接上的数据收发以及请求业务逻辑 处理!!! ","date":"2025-09-30","objectID":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/:2:0","series":null,"tags":["网络","linux"],"title":"一台linux最大能支持多少条TCP连接","uri":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/#一台服务器最大能支持多少连接"},{"categories":["documentation"],"content":" 3 一台客户端机器最多能发起多少条连接我们知道客户端每和服务端建立一个连接便会消耗掉client端一个端口。一台机器的端口 范围是【0~65535】,那么是不是说一台client机器最多和一台服务端机器建立65535个 连接呢(这65535个端口里还有很多保留端口,可用端口可能只有64000个左右)? 开始实验之前我们先来check下手头机器上的端口数量的配置 bash $ sysctl -a | grep ip_local_port_range net.ipv4.ip_local_port_range = 15000 65000 通过上述内核参数的输出看到内核开放了50000个端口可以供TCP连接使用。 当Linux作为客户端建立连接的时候,最大连接数量是受内核参数net.ipv4.ip_local_port_range限制 mip_local_port_range是可配置的,最大理论范围是0-65535 对于只有1个ip的客户端来说,受限于ip_local_port_range参数,也受限于65535。但Linux可以配置多个ip,有几个ip,最大理论值就翻几倍 多张网卡不是必须的。即使只有一张网卡,也可以配置多ip。 k8s就是这么干的,在k8s里,一台物理机上可以部署多个pod。 但每一个pod都会被分配一个独立的ip,所以完全不用担心物理机上部署了过多的pod而影响你用的pod里的TCP连接数量。 在ip给你的那一刻,你的pod就和其它应用隔离开了。 ##结论 TCP连接的客户端机:每一个ip可建立的TCP连接理论受限于ip_loca_port_range参数,也受限于65535。但可以通过配置多ip的方式来加大自己的建立连接的能力。 TCP连接的服务器机:每一个监听的端口虽然理论值很大,但这个数字没有实际意义。最大并发数取决你的内存大小,每一条静止状态的TCP连接大约需要吃 3.3K 的内存。 ","date":"2025-09-30","objectID":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/:3:0","series":null,"tags":["网络","linux"],"title":"一台linux最大能支持多少条TCP连接","uri":"/%E4%B8%80%E5%8F%B0linux%E6%9C%80%E5%A4%A7%E8%83%BD%E6%94%AF%E6%8C%81%E5%A4%9A%E5%B0%91%E6%9D%A1tcp%E8%BF%9E%E6%8E%A5/#一台客户端机器最多能发起多少条连接"},{"categories":["documentation"],"content":" 概要说到WS，不得不提HTTP,HTTP是基于TCP，面向文本的，无状态的，半双工通信协议。由于HTTP1.0的缺陷，后面版本做相应的优化： 每次请求都要建立TCP连接，并且请求一个文档需要两倍RTT(一个是TCP握手，一个是请求和接收文档)。针对这种情况HTTP1.1引入了keep-alive机制，实现了建立一次TCP连接，可发送多次请求。 HTTP是明文传输，所以有一个中间人攻击的漏洞。针对这种情况引入了HTTPS(HTTP+TLS),实现了防窃听（数据加密）、防冒充（身份验证）、防篡改（完整性校验）。 HTTP的请求一般是非流水线模式【收到上一个请求的响应后才能发下一个请求】（注意现代浏览器并不启用流水线模式，实现复杂，问题多），这里有队头阻塞问题（现代浏览器一般通过开多个tcp连接来进行一定程度上的规避），所以有了HTTP2。 HTTP2只是解决了应用层的队头阻塞问题，但是TCP有丢包重传等机制，所以传输层也有队头阻塞问题，这个时候就要HTTP3登场了，引入 QUIC 协议，基于UDP,可以完美解决队头阻塞问题。 通过上面分析HTTP迭代的原因，那么WS的出现是为了解决HTTP什么问题呢？ 针对HTTP请求-响应这种半双工通信模式，既要实现全双工通信 为什么要这样呢？主要是因为在没有WS之前，HTTP要实现IM,服务端事件推送等实时场景是很麻烦的，常见的有短轮询，长轮询，SSE（Server Send Event)，针对实时通讯的场景方案都不是很优秀，所以有了WS，它最初是在 HTML5 中引入的。经过多年发展后，该协议慢慢被多个浏览器支持，RFC 在 2011 年就把该协议作为一个国际标准，叫 rfc6455。 也许是为了修复HTTP缺陷而诞生的，所以WS的建立是依赖HTTP的，同样规定默认使用80,443端口，当然其错误码是与HTTP不重合的。 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:0:0","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#概要"},{"categories":["documentation"],"content":" 1 WS原理WebSocket 是一种基于TCP长连接，面向报文（二进制），支持全双工通信的网络协议。其与HTTP是平级的，相比HTTP1.1,优点如下： 支持全双工通信，实时性更强； 客户端与服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息。即发送端将消息切割成多个帧，并发送给接收端；接收端接收消息帧，并将关联的帧重新组装成完整的消息； 长连接，有状态； 较少的控制开销。连接创建后，WS客户端、服务端进行数据交换时，协议控制的数据包头部较小，不像HTTP每次请求都要携带那么多头； 支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议（比如支持自定义压缩算法等）。 HTTP1.1的非流水线请求模式如下图： 可以看到HTTP1.1 强调请求与响应一对一，一个请求的响应回来了才会发出下一个请求。 WS请求模式如下图： 可以看到WS中的req与rsp的发起与返回非常自由，没有一对一的概念。 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:1:0","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#ws原理"},{"categories":["documentation"],"content":" 1.1 帧格式WebSocket主要是解决HTTP无法实时通信的问题，所以没有HTTP2 的多路复用，优先级等复杂功能，所以二进制帧格式简单： 可以看到帧头是16bit，2字节： 第一个字节： 前四位是标志位，第一个标志位是FIN,表示报文结束，因为一个消息可能被拆分成多帧，当接收方收到携带FIN标志位的帧时，就会把前面的帧拼起来组成完整的消息。后三位是保留标志位，必须设置为0，除非想要自定义扩展。 后四位是opcode,也就是帧类型，比如0表示连续帧，1表示帧内容是文本，2表示帧内容是二进制，8表示关闭连接，9和10表示ping和pong等 第二个字节： 它的第一位是掩码标志位 MASK，表示帧内容是否使用异或操作（xor）做简单的加密，当该位被设置为 1 时表示加密，那么后续会设置4字节的Masking-key，设置为 0 时表示不加密，就不会携带Masking-key了。如果加密了，那么必须解密才能得到正确内容。目前的 WebSocket 标准规定，客户端发送数据必须使用掩码加密，而服务器发送则不使用掩码加密。 后面7位表示Payload Length，也就是有效负载或者说有效业务消息的长度，并且采用的是大端存储。但是7位大表示127，如果payload data大于127字节咋办？？ 所以就引入了 Extended payload length 来表示真是的Payload Length： Payload Length ==127，则 后面8字节表示 Extended payload length； Payload Length ==126，则 后面2字节表示 Extended payload length； Payload Length \u003c 126，则 没有 Extended payload length； 可知最大payload data长度 可以用8字节表示。 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:1:1","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#帧格式"},{"categories":["documentation"],"content":" 2 WS实战 WS是基于HTTP协议实现的。 WSS是基于HTTPS协议实现的,即完成tls握手后再进行协议升级。 WS建立复用了 HTTP 的握手请求过程。 客户端通过 HTTP 请求与 WebSocket 服务端协商升级协议。协议完成后，后续的数据交互则遵循 WebSocket 的协议。 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:2:0","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#ws实战"},{"categories":["documentation"],"content":" 2.1 客户端发起协议升级请求 bash GET /websocket HTTP/1.1 Host: 127.0.0.1:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Sec-WebSocket-Version: 13 #表示WS的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader头，里面包含服务端支持的版本号 Origin: http://www.jsons.cn Sec-WebSocket-Extensions: permessage-deflate Sec-WebSocket-Key: 9zQPEx8m0sqMkV1vanwJIA== #与服务端响应首部的Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接(比如特殊的HTTP请求被意外识别成WS) Connection: keep-alive, Upgrade #告诉服务端要升级协议了 Sec-Fetch-Dest: websocket Sec-Fetch-Mode: websocket Sec-Fetch-Site: cross-site Pragma: no-cache Cache-Control: no-cache Upgrade: websocket #告诉服务端要升级成WS协议 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:2:1","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#客户端发起协议升级请求"},{"categories":["documentation"],"content":" 2.2 服务端响应协议升级 bash HTTP/1.1 101 Switching Protocols #状态码 101 表示协议切换成功 Upgrade: websocket #表示升级到WS协议 Connection: Upgrade #表示协议升级 Sec-WebSocket-Accept: MzzLu4vmstovah28VVOvEgveq8o= #根据客户端请求首部的 Sec-WebSocket-Key 计算出来 #将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接。 #通过 SHA1 计算出摘要，并转成 base64 字符串。计算公式如下： # Base64(sha1(Sec-WebSocket-Key + 258EAFA5-E914-47DA-95CA-C5AB0DC85B11)) 协议升级完成后就完全遵循WS协议发送接收数据了。 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:2:2","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#服务端响应协议升级"},{"categories":["documentation"],"content":" 2.3 核心事件WebSocket协议也是事件驱动的，客户应用程序不需要轮序服务来得到更新的数据，消息和事件将在服务器发送它们的时候异步到达。 open 连接建立时触发 message 接收/发送消息时触发 error 通信发生错误时触发 close 连接关闭时触发 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:2:3","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#核心事件"},{"categories":["documentation"],"content":" 2.4 心跳保活这个其实在1.1小节已经说过了，就是opcode类型，通过ping和pong来实现，不需要自己再写保活接口了，只需要使用ping/pong即可。 以go gorilla/websocket为例： go func WebSocket(c *gin.Context) { //支持协议升级 conn, err := (\u0026websocket.Upgrader{CheckOrigin: func(r *http.Request) bool { return true }}).Upgrade(c.Writer, c.Request, nil) if err != nil { http.NotFound(c.Writer, c.Request) return } //添加保活机制 conn.SetPongHandler(func(appData string) error { library.ZapDebug(appData) //check something return nil }) //deal websocket connect for { //接收消息 mt, msg, err := conn.ReadMessage() if err != nil { //错误，打Trace，因为可能是主动或者网络问题 library.ZapDebug(\"ReadMessage err:%v\", err) continue } //这里可以go func(){}() 包一下解决并发问题 { //业务处理 library.ZapDebug(\"mt=%v,msg=%v\", mt, string(msg)) //响应消息 err = conn.WriteMessage(mt, []byte(fmt.Sprintf(\"hello:%s\", msg))) if err != nil { library.ZapDebug(\"WriteMessage err:%v\", err) } } } } ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:2:4","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#心跳保活"},{"categories":["documentation"],"content":" 2.5 注意WS无多路复用HTTP2为了提高传送效率，引入了多路复用，即流的概念，每个请求都有自己专属的流id，来保证并发请求下服务端响应的内容精准匹配到对应的请求。从在1.1节中看到WS显然不支持这样的情况，即WS下先后发出a,b两个请求，WS并不保证a的返回一定先于b。这一点在使用中需要注意的。 还是以下面的代码为例： go func WebSocket(c *gin.Context) { conn, err := (\u0026websocket.Upgrader{CheckOrigin: func(r *http.Request) bool { return true }}).Upgrade(c.Writer, c.Request, nil) if err != nil { http.NotFound(c.Writer, c.Request) return } //保活 conn.SetPongHandler(func(appData string) error { library.ZapDebug(appData) //check something return nil }) // websocket connect for { mt, msg, err := conn.ReadMessage() if err != nil { //客户端错误，打Trace，因为可能是主动或者网络问题 library.ZapDebug(\"err:%v\", err) continue } //这里可以go func(){}() 包一下解决并发问题 go func() { //业务处理 library.ZapDebug(\"mt=%v,msg=%v\", mt, string(msg)) t, _ := strconv.ParseInt(string(msg), 10, 64) time.Sleep(time.Duration(t) * time.Second) //sleep一下，人为实现后面的请求比前面的请求先返回 //响应消息 err = conn.WriteMessage(mt, []byte(fmt.Sprintf(\"hello:%s\", msg))) if err != nil { library.ZapDebug(\"err:%v\", err) } }() } } 测试网址 可以观察到 WS下先后发出a,b两个请求，会出现 b请求先于a请求先返回的。 原因： TCP是面向字节流的，WS协议简单，可以说只是在TCP之上提供了数据拆包组包的功能，那么WS在收包时只能保证消息是完整的，并不管是谁发出的，只要有完整消息就会触发message 事件接收消息。 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:2:5","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#注意ws无多路复用"},{"categories":["documentation"],"content":" 3 总结经过上述内容，可以知道WS可以看做是对HTTP打的补丁，主要是为了解决HTTP半双工通信弊端，侧重处理数据实时通信场景。 这里再说下WS为什么没有替代HTTP，反而后面出了一样支持长连接的HTTP2 ？ WS协议简单，可以说只是在TCP之上提供了数据拆包组包的功能。所以对于静态资源的请求效率是低下的，而不像HTTP2提供了多路复用，请求优先级等特性来提高传输效率，增强页面渲染。 长连接，全双工通信是WS相比于HTTP的一大优势，其实HTTP2也有，但奈何浏览器为了提高页面渲染效率往往还是同时开多个TCP连接。可以这样说，WS与HTTP各有优势，在页面渲染和短请求场景下选HTTP，在实时通信，如IM等场景下选WS,二者结合使用最好。 长连接也并不是银弹，随着在线用户增加，相同资源下，其最大在线用户数量理论上不如HTTP。 长连接的负载均衡不如短连接灵活，简单。 WS并不天然支持请求-响应一对一模式，但是网页渲染，接口请求这样的场景是需要，要想实现就要人为控制，所以此类场景下不如HTTP香。 可以这样说，如果不是浏览器是个沙盒环境，不允许用户使用TCP，说不定WS压根不会诞生。 原文链接：https://blog.csdn.net/weixin_38597669/article/details/131885507 ","date":"2025-09-28","objectID":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/:3:0","series":[""],"tags":["网络"],"title":"Websocket协议解析","uri":"/websocket%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/#总结"},{"categories":["documentation"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念.","date":"2020-03-03","objectID":"/theme-documentation-basics/","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:0:0","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#"},{"categories":["documentation"],"content":" 6 准备由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本 Hugo (\u003e 0.122.0). 为什么不支持早期版本的 Hugo? 由于 WebP 图像处理 在 Hugo 0.122.0版本 中被引入, 本主题只支持高于 0.122.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将 SCSS 转换为 CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:1:0","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#准备"},{"categories":["documentation"],"content":" 7 安装以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:0","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#安装"},{"categories":["documentation"],"content":" 7.1 创建你的项目Hugo 提供了一个 new 命令来创建一个新的网站: bash hugo new site my_website cd my_website ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:1","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#创建你的项目"},{"categories":["documentation"],"content":" 7.2 安装主题DoIt 主题的仓库是: https://github.com/HEIGE-PCloud/DoIt. 你可以下载主题的 最新版本 .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: bash git clone https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: bash git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:2","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#安装主题"},{"categories":["documentation"],"content":" 7.3 基础配置以下是 DoIt 主题的基本配置: toml baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:3","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#basic-configuration"},{"categories":["documentation"],"content":" 7.4 创建你的第一篇文章以下是创建第一篇文章的方法: bash hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:4","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#创建你的第一篇文章"},{"categories":["documentation"],"content":" 7.5 在本地启动网站使用以下命令启动网站: bash hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. bash hugo serve --disableFastRender ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:5","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#在本地启动网站"},{"categories":["documentation"],"content":" 7.6 构建网站当你准备好部署你的网站时, 运行以下命令: bash hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:6","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#构建网站"},{"categories":["documentation"],"content":" 8 配置","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:0","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#配置"},{"categories":["documentation"],"content":" 8.1 网站配置除了 Hugo 全局配置 和 菜单配置 之外, DoIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : toml [params] # DoIt 主题版本 version = \"0.4.X\" # 网站名称 title = \"我的全新 Hugo 网站\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"black\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径, 仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 开启 PWA 支持 enablePWA = false # [试验性功能] 缓存markdown中的图片链接到本地，详情请见：https://github.com/HEIGE-PCloud/DoIt/pull/860#issue-1574342372 cacheRemoteImages = true # [试验性功能] 使用 hugo 自带的图片处理功能生成 srcset 属性 optimizeImages = true # [实验性功能] optimizeImages 中 srcset 属性的缩放方法, 详情请见：https://gohugo.io/content-management/image-processing/#image-processing-options srcsetSmallResizeMethod = \"700x webp Lanczos q75\" srcsetDefaultResizeMethod = \"1200x webp Lanczos q75\" srcsetLargeResizeMethod = \"2000x webp Lanczos q75\" # 版权信息 license = '\u003ca rel=\"license external nofollow noopener noreferrer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # 作者配置 [params.author] name = \"xxxx\" email = \"\" link = \"\" avatar = \"\" gravatarEmail = \"\" # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"DoIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false [params.image] # 缓存图片链接到本地 cacheRemote = true # 图片缩放和优化 optimise = true # 页面头部导航栏配置 [params.header] # 主题切换模式 # 主题切换模式 (\"switch\", \"select\") themeChangeMode = \"select\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 托管服务信息 (支持 HTML 格式) # \u003ca title=\"Github Pages\" href=\"https://docs.github.com/en/pages/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eGitHub Pages\u003c/a\u003e hostedOn = '' # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息, 仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreferrer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 最近更新文章设置 [params.section.recentlyUpdated] enable = false rss = false days = 30 maxCount = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱, 用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL # 将你的头像文件放置于 static 或者 assets 目录下 # 文件路径是相对于 static 或者 assets 目录的 avatarURL = \"/images/avatar.webp\" # 头像的链接指向的 URL avatarLinkURL = \"\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hidd","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:1","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#site-configuration"},{"categories":["documentation"],"content":" 8.2 网站图标, 浏览器配置, 网站清单强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:2","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#网站图标-浏览器配置-网站清单"},{"categories":["documentation"],"content":" 8.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, DoIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/DoIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: scss @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:3","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#自定义样式"},{"categories":["documentation"],"content":" 9 多语言和 i18nDoIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:0","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#多语言和-i18n"},{"categories":["documentation"],"content":" 9.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi Arabic ar ar Catalan ca ca Hindi hi hi Indonesian id id Telugu te te Thai th th Turkish tr tr Ukrainian uk uk Traditional Chinese zh-tw zh-tw ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:1","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#language-compatibility"},{"categories":["documentation"],"content":" 9.2 基本配置学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: toml # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为两个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:2","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#基本配置"},{"categories":["documentation"],"content":" 9.3 修改默认的翻译字符串翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件, 并从 themes/DoIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过 创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:3","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#修改默认的翻译字符串"},{"categories":["documentation"],"content":" 10 搜索 基于 Lunr.js 或 algolia, DoIt 主题支持搜索功能. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:5:0","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#搜索"},{"categories":["documentation"],"content":" 10.1 输出配置为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. toml [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-03","objectID":"/theme-documentation-basics/:5:1","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#输出配置"},{"categories":["documentation"],"content":" 10.2 搜索配置基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: toml [params.search] enable = true # 搜索引擎的类型 (\"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false 怎样选择搜索引擎? 以下是两种搜索引擎的对比: fuse: 简单, 无需同步 index.json, 没有 contentLength 的限制, 性能高 algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json…","date":"2020-03-03","objectID":"/theme-documentation-basics/:5:2","series":["getting-start"],"tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#搜索配置"},{"categories":["documentation"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-04","objectID":"/theme-documentation-content/","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-04","objectID":"/theme-documentation-content/:0:0","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#"},{"categories":["documentation"],"content":" 7 内容组织以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-04","objectID":"/theme-documentation-content/:1:0","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#contents-organization"},{"categories":["documentation"],"content":" 8 作者配置我们鼓励你在 mysite/data/authors 下创建你的作者个人资料 author_name.toml. 在你的资料中, 你可以添加个人链接, 邮箱, 以及支持 i18n 的姓名. 以下是 Alice.toml 的示例: toml link = \"https://alice.example.com\" email = \"alice@example.com\" name = \"Alice\" [zh-cn] name = \"爱丽丝\" 在创建作者个人资料后, 您可以在文章的前置参数中指定您的姓名. 之后, 该文章将自动著上你的名字, 并可以根据作者进行分类. yaml --- authors: [Alice] --- 您也可以为一篇文章注明多个作者. yaml --- authors: [Alice, Bob, Catherine] --- ","date":"2020-03-04","objectID":"/theme-documentation-content/:2:0","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#author-setup"},{"categories":["documentation"],"content":" 9 前置参数Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: yaml --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true authors: [] description: \"\" license: \"\" images: [] tags: [] categories: [] series: [] series_weight: 1 seriesNavigation: true featuredImage: \"\" featuredImagePreview: \"\" hiddenFromHomePage: false hiddenFromSearch: false twemoji: false lightgallery: true ruby: true fraction: true linkToMarkdown: true linkToSource: false linkToEdit: false linkToReport: false rssFullText: false license: '' toc: enable: true auto: true code: copy: true # ... table: sort: true # ... math: enable: true # ... mapbox: accessToken: \"\" # ... share: enable: true # ... comment: enable: true # ... library: css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: images: [] # ... outdatedArticleReminder: enable: false # ... sponsor: enable: false # ... related: enable: false count: 5 --- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. authors: 文章作者. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. series: 文章所属的系列. series_weight: 自定义文章在系列中的位置. seriesNavigation: 是否使用系列导航. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. linkToSource: 如果设为 false, 则关闭页脚 view source 的链接. 你可以将其设置为一个指向文章原始文件的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md. linkToEdit: 如果设为 false, 则关闭页脚 编辑此页 的链接. 你可以将其设置为一个用于编辑这个页面的链接. 使用魔法变量 {path} 来获取这篇文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.zh-cn.md. linkToReport: 如果设为 false, 则关闭页脚 报告问题 的链接. 你可以将其设置为一个用于报告此页面中错误的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md, 使用 {title} 来获取文章的标题, 这篇文章的 {title} 为 Theme Documentation - Content, 使用 {url} 来获取文章的链接, 这篇文章的 {url} 为 https://hugodoit.pages.dev/theme-documentation-content/. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. enableLastMod: 如果设为 true，在文章的顶部将会显示上次修改内容的日期时间. enableWordCount: 如果设为 true, 在文章的顶部将会显示文章的字数. enableReadingTime: 如果设为 true, 在文章的顶部将会显示文章的阅读时间. license: 许可协议信息 (支持 HTML 格式). toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. table: 和 网站配置 中的 params.page.table 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. outdatedArticleReminder: 和 网站配置 中的 params.page.outdatedArticleReminder 部分相同. sponsor: 和 网站配置 中的 params.sponsor 部分相同. related: 和 网站配置 中的 params.page.related 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: yaml resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg ","date":"2020-03-04","objectID":"/theme-documentation-content/:3:0","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#front-matter"},{"categories":["documentation"],"content":" 10 内容摘要DoIt 主题使用内容摘要在主页中显示大致文章信息. Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:0","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#内容摘要"},{"categories":["documentation"],"content":" 10.1 自动摘要拆分默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能, 请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:1","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#自动摘要拆分"},{"categories":["documentation"],"content":" 10.2 手动摘要拆分另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:2","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#手动摘要拆分"},{"categories":["documentation"],"content":" 10.3 前置参数摘要你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:3","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#前置参数摘要"},{"categories":["documentation"],"content":" 10.4 使用文章描述作为摘要你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 DoIt 主题会将你的文章描述作为摘要. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:4","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#使用文章描述作为摘要"},{"categories":["documentation"],"content":" 10.5 摘要选择的优先级顺序由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:5","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#摘要选择的优先级顺序"},{"categories":["documentation"],"content":" 11 Markdown 基本语法这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-04","objectID":"/theme-documentation-content/:5:0","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#markdown-基本语法"},{"categories":["documentation"],"content":" 12 Markdown 扩展语法DoIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:0","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#extended-markdown-syntax"},{"categories":["documentation"],"content":" 12.1 Emoji 支持这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:1","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#emoji-支持"},{"categories":["documentation"],"content":" 12.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中添加如下设置来启用数学公式支持： hugo.toml [markup] [markup.goldmark] [markup.goldmark.extensions] [markup.goldmark.extensions.passthrough] enable = true [markup.goldmark.extensions.passthrough.delimiters] block = [['\\[', '\\]']] inline = [['\\(', '\\)']] [params] [page] [page.math] enable = true blockLeftDelimiter = '\\[' blockRightDelimiter = '\\]' inlineLeftDelimiter = '\\(' inlineRightDelimiter = '\\)' copyTex = true mhchem = true 技巧 这是一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 列表。 12.2.1 公式块默认的公式块分割符是 \\[ \\]： markdown \\[ c = \\pm\\sqrt{a^2 + b^2} \\] \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 呈现的输出效果如下： c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.2 行内公式默认的行内公式分割符是 \\( \\)： markdown \\( c = \\pm\\sqrt{a^2 + b^2} \\) and \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 呈现的输出效果如下: c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​ and f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 12.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. markdown \\[ \\ce{CO2 + C -\u003e 2 CO} \\] \\[ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} \\] 呈现的输出效果如下: COX2+C→2 CO \\ce{CO2 + C -\u003e 2 CO} COX2​+C​2COHgX2+→IX−HgIX2→IX−[HgXIIIX4]X2− \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} HgX2+IX−​HgIX2​IX−​[HgXIIIX4​]X2−","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#数学公式"},{"categories":["documentation"],"content":" 12.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中添加如下设置来启用数学公式支持： hugo.toml [markup] [markup.goldmark] [markup.goldmark.extensions] [markup.goldmark.extensions.passthrough] enable = true [markup.goldmark.extensions.passthrough.delimiters] block = [['\\[', '\\]']] inline = [['\\(', '\\)']] [params] [page] [page.math] enable = true blockLeftDelimiter = '\\[' blockRightDelimiter = '\\]' inlineLeftDelimiter = '\\(' inlineRightDelimiter = '\\)' copyTex = true mhchem = true 技巧 这是一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 列表。 12.2.1 公式块默认的公式块分割符是 \\[ \\]： markdown \\[ c = \\pm\\sqrt{a^2 + b^2} \\] \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 呈现的输出效果如下： c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.2 行内公式默认的行内公式分割符是 \\( \\)： markdown \\( c = \\pm\\sqrt{a^2 + b^2} \\) and \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 呈现的输出效果如下: c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​ and f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 12.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. markdown \\[ \\ce{CO2 + C -\u003e 2 CO} \\] \\[ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} \\] 呈现的输出效果如下: COX2+C→2 CO \\ce{CO2 + C -\u003e 2 CO} COX2​+C​2COHgX2+→IX−HgIX2→IX−[HgXIIIX4]X2− \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} HgX2+IX−​HgIX2​IX−​[HgXIIIX4​]X2−","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#公式块"},{"categories":["documentation"],"content":" 12.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中添加如下设置来启用数学公式支持： hugo.toml [markup] [markup.goldmark] [markup.goldmark.extensions] [markup.goldmark.extensions.passthrough] enable = true [markup.goldmark.extensions.passthrough.delimiters] block = [['\\[', '\\]']] inline = [['\\(', '\\)']] [params] [page] [page.math] enable = true blockLeftDelimiter = '\\[' blockRightDelimiter = '\\]' inlineLeftDelimiter = '\\(' inlineRightDelimiter = '\\)' copyTex = true mhchem = true 技巧 这是一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 列表。 12.2.1 公式块默认的公式块分割符是 \\[ \\]： markdown \\[ c = \\pm\\sqrt{a^2 + b^2} \\] \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 呈现的输出效果如下： c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.2 行内公式默认的行内公式分割符是 \\( \\)： markdown \\( c = \\pm\\sqrt{a^2 + b^2} \\) and \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 呈现的输出效果如下: c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​ and f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 12.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. markdown \\[ \\ce{CO2 + C -\u003e 2 CO} \\] \\[ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} \\] 呈现的输出效果如下: COX2+C→2 CO \\ce{CO2 + C -\u003e 2 CO} COX2​+C​2COHgX2+→IX−HgIX2→IX−[HgXIIIX4]X2− \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} HgX2+IX−​HgIX2​IX−​[HgXIIIX4​]X2−","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#行内公式"},{"categories":["documentation"],"content":" 12.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中添加如下设置来启用数学公式支持： hugo.toml [markup] [markup.goldmark] [markup.goldmark.extensions] [markup.goldmark.extensions.passthrough] enable = true [markup.goldmark.extensions.passthrough.delimiters] block = [['\\[', '\\]']] inline = [['\\(', '\\)']] [params] [page] [page.math] enable = true blockLeftDelimiter = '\\[' blockRightDelimiter = '\\]' inlineLeftDelimiter = '\\(' inlineRightDelimiter = '\\)' copyTex = true mhchem = true 技巧 这是一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 列表。 12.2.1 公式块默认的公式块分割符是 \\[ \\]： markdown \\[ c = \\pm\\sqrt{a^2 + b^2} \\] \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 呈现的输出效果如下： c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.2 行内公式默认的行内公式分割符是 \\( \\)： markdown \\( c = \\pm\\sqrt{a^2 + b^2} \\) and \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 呈现的输出效果如下: c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​ and f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 12.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. markdown \\[ \\ce{CO2 + C -\u003e 2 CO} \\] \\[ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} \\] 呈现的输出效果如下: COX2+C→2 CO \\ce{CO2 + C -\u003e 2 CO} COX2​+C​2COHgX2+→IX−HgIX2→IX−[HgXIIIX4]X2− \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} HgX2+IX−​HgIX2​IX−​[HgXIIIX4​]X2−","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#copy-tex"},{"categories":["documentation"],"content":" 12.2 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中添加如下设置来启用数学公式支持： hugo.toml [markup] [markup.goldmark] [markup.goldmark.extensions] [markup.goldmark.extensions.passthrough] enable = true [markup.goldmark.extensions.passthrough.delimiters] block = [['\\[', '\\]']] inline = [['\\(', '\\)']] [params] [page] [page.math] enable = true blockLeftDelimiter = '\\[' blockRightDelimiter = '\\]' inlineLeftDelimiter = '\\(' inlineRightDelimiter = '\\)' copyTex = true mhchem = true 技巧 这是一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 列表。 12.2.1 公式块默认的公式块分割符是 \\[ \\]： markdown \\[ c = \\pm\\sqrt{a^2 + b^2} \\] \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 呈现的输出效果如下： c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.2 行内公式默认的行内公式分割符是 \\( \\)： markdown \\( c = \\pm\\sqrt{a^2 + b^2} \\) and \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 呈现的输出效果如下: c=±a2+b2 c = \\pm\\sqrt{a^2 + b^2} c=±a2+b2​ and f(x)=∫−∞∞f^(ξ)e2πiξxdξ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi f(x)=∫−∞∞​f^​(ξ)e2πiξxdξ 12.2.3 Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. 12.2.4 mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. markdown \\[ \\ce{CO2 + C -\u003e 2 CO} \\] \\[ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} \\] 呈现的输出效果如下: COX2+C→2 CO \\ce{CO2 + C -\u003e 2 CO} COX2​+C​2COHgX2+→IX−HgIX2→IX−[HgXIIIX4]X2− \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} HgX2+IX−​HgIX2​IX−​[HgXIIIX4​]X2−","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#mhchem"},{"categories":["documentation"],"content":" 12.3 字符注音或者注释DoIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: markdown [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:3","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#ruby"},{"categories":["documentation"],"content":" 12.4 分数 DoIt 主题支持一种 分数 Markdown 扩展语法: markdown [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:4","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#fraction"},{"categories":["documentation"],"content":" 12.5 BlockquotesDoIt 支持 GitHub 风格的引用块： markdown \u003e [!NOTE] \u003e Useful information that users should know, even when skimming content. \u003e [!TIP] \u003e Helpful advice for doing things better or more easily. \u003e [!IMPORTANT] \u003e Key information users need to know to achieve their goal. \u003e [!WARNING] \u003e Urgent info that needs immediate user attention to avoid problems. \u003e [!CAUTION] \u003e Advises about risks or negative outcomes of certain actions. 呈现的输出效果如下： Note Useful information that users should know, even when skimming content. Tip Helpful advice for doing things better or more easily. Important Key information users need to know to achieve their goal. Warning Urgent info that needs immediate user attention to avoid problems. Caution Advises about risks or negative outcomes of certain actions. ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:5","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#blockquotes"},{"categories":["documentation"],"content":" 12.6 PlantUML支持DoIt 支持 PlantUML 绘图： markdown ```plantuml {format=\"svg\" title=\"example\"} @startuml test Bob -\u003e Alice : hello @enduml ``` 呈现的输出效果如下： 你可以通过以下可选参数自定义 PlantUML 的渲染结果： 选项 描述 类型 format PlantUML 渲染的输出类型，可以是 svg （默认）或者 png string title 会被渲染为 \u003cimg\u003e 标签的 alt 属性 string ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:6","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#plantuml支持"},{"categories":["documentation"],"content":" 12.7 WaveDrom支持 Tip 这是一份 WaveDrom 常用示例及教程。 DoIt 支持 WaveDrom 绘图： markdown ```wavedrom {signal: [ {name: 'clock', wave: 'p................'}, {name: 'hwrite', wave: 'x0x.0x..0.x.0.x..'}, {name: 'htrans', wave: 'x3x.4x..5.x.6.x..', data: '2 2 2 2'}, {name: 'haddr', wave: 'x3x.4x..5.x.6.x..', data: 'A0 A1 A2 A3'}, {}, {name: 'hready', wave: 'x1.x101x01.x0101x'}, {name: 'hrdata', wave: 'x.3x..4x..5x...6x', data: 'D0 D1 D2 D3'}, ], head: {tock: 1}, gaps: '( . . 1 . s . 1 s . . 1 s . s . )', foot: {text: 'reads'} } ``` 呈现的输出效果如下： ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:7","series":["getting-start"],"tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#wavedrom支持"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:0:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#"},{"categories":["documentation"],"content":" 1 figurefigure 的文档 一个 figure 示例: markdown {{\u003c figure src=\"/images/lighthouse.webp\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: html \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.webp\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:1:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#figure"},{"categories":["documentation"],"content":" 2 gistgist 的文档 一个 gist 示例: markdown {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: html \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:2:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#gist"},{"categories":["documentation"],"content":" 3 paramparam 的文档 一个 param 示例: markdown {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:3:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#param"},{"categories":["documentation"],"content":" 4 ref 和 relrefref 和 relref 的文档 ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:4:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#ref-and-relref"},{"categories":["documentation"],"content":" 5 xx 的文档 一个 x 示例: markdown {{\u003c x user=\"SanDiegoZoo\" id=\"1453110110599868418\" \u003e}} ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:5:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#x"},{"categories":["documentation"],"content":" 6 vimeovimeo 的文档 一个 vimeo 示例: markdown {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:6:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#vimeo"},{"categories":["documentation"],"content":" 7 youtubeyoutube 的文档 一个 youtube 示例: markdown {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:7:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#youtube"},{"categories":["documentation"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:0:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#"},{"categories":["documentation"],"content":" 19 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持 SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: markdown {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:1:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#style"},{"categories":["documentation"],"content":" 20 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: markdown {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: markdown {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上, 会有一行提示): Upstage ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:2:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#link"},{"categories":["documentation"],"content":" 21 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lightgallery.js. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. optimise [可选] 图片是否需要被优化，覆盖全局配置。 cacheRemote [可选] 是否缓存远程图片，覆盖全局配置。 一个 image 示例: markdown {{\u003c image src=\"/images/lighthouse.webp\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.webp\" src_l=\"/images/lighthouse-large.webp\" \u003e}} 呈现的输出效果如下: Lighthouse (image) ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:3:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#image"},{"categories":["documentation"],"content":" 22 admonitionadmonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: markdown {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:4:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#admonition"},{"categories":["documentation"],"content":" 23 mermaidmermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#mermaid"},{"categories":["documentation"],"content":" 23.1 流程图一个 流程图 mermaid 示例: markdown {{\u003c mermaid \u003e}}graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:1","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#flowchart"},{"categories":["documentation"],"content":" 23.2 时序图一个 时序图 mermaid 示例: markdown {{\u003c mermaid \u003e}}sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:2","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#sequence-diagram"},{"categories":["documentation"],"content":" 23.3 甘特图一个 甘特图 mermaid 示例: markdown {{\u003c mermaid \u003e}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:3","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#gantt"},{"categories":["documentation"],"content":" 23.4 类图一个 类图 mermaid 示例: markdown {{\u003c mermaid \u003e}}classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:4","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#class-diagram"},{"categories":["documentation"],"content":" 23.5 状态图一个 状态图 mermaid 示例: markdown {{\u003c mermaid \u003e}}stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:5","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#state-diagram"},{"categories":["documentation"],"content":" 23.6 Git 图一个 Git 图 mermaid 示例: markdown {{\u003c mermaid \u003e}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:6","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#git-graph"},{"categories":["documentation"],"content":" 23.7 饼图一个 饼图 mermaid 示例: markdown {{\u003c mermaid \u003e}}pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:7","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#pie"},{"categories":["documentation"],"content":" 24 echartsECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: json {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: yaml {{\u003c echarts \u003e}} title: text: 折线统计图 top: 2% left: center tooltip: trigger: axis legend: data: - 邮件营销 - 联盟广告 - 视频广告 - 直接访问 - 搜索引擎 top: 10% grid: left: 5% right: 5% bottom: 5% top: 20% containLabel: true toolbox: feature: saveAsImage: title: 保存为图片 xAxis: type: category boundaryGap: false data: - 周一 - 周二 - 周三 - 周四 - 周五 - 周六 - 周日 yAxis: type: value series: - name: 邮件营销 type: line stack: 总量 data: - 120 - 132 - 101 - 134 - 90 - 230 - 210 - name: 联盟广告 type: line stack: 总量 data: - 220 - 182 - 191 - 234 - 290 - 330 - 310 - name: 视频广告 type: line stack: 总量 data: - 150 - 232 - 201 - 154 - 190 - 330 - 410 - name: 直接访问 type: line stack: 总量 data: - 320 - 332 - 301 - 334 - 390 - 330 - 320 - name: 搜索引擎 type: line stack: 总量 data: - 820 - 932 - 901 - 934 - 1290 - 1330 - 1320 {{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: toml {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:6:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#echarts"},{"categories":["documentation"],"content":" 25 mapbox Mapbox GL JS 是一个 JavaScript 库, 它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: markdown {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: markdown {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:7:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#mapbox"},{"categories":["documentation"],"content":" 26 musicmusic shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#music"},{"categories":["documentation"],"content":" 26.1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: markdown {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.webp\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:1","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#custom-music-url"},{"categories":["documentation"],"content":" 26.2 音乐平台 URL 的自动识别music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: markdown {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:2","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#automatic-identification"},{"categories":["documentation"],"content":" 26.3 自定义音乐平台, 类型和 IDmusic shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: markdown {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:3","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#custom-server"},{"categories":["documentation"],"content":" 26.4 其它参数music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:4","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#other-parameters"},{"categories":["documentation"],"content":" 27 aplayer and audio 如果你需要针对音乐播放器的更多自定义选项（如自定义歌单，迷你模式，自定义音乐类型以及更多…），你可以使用 aplayer shortcode 配合 audio shortcode 以发挥 APlayer.js 的全部功能。 aplayer shortcode 用于创建一个 APlayer 播放器实例，audio shortcode 则用于设置音乐文件的相关信息。请查看 APlayer.js 的文档 来了解所有的可配置项。 一个 aplayer 和 audio 的示例： markdown {{\u003c aplayer fixed=false mini=false autoplay=false theme=\"#b7daff\" loop=\"all\" order=\"list\" preload=\"auto\" volume=0.7 mutex=true lrcType=1 listFolded=false listMaxHeight=\"\" storageName=\"aplayer-setting\" \u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" /\u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" \u003e}} [00:00.00]APlayer audio1 [00:04.01]is [00:08.02]amazing {{\u003c /audio \u003e}} {{\u003c /aplayer \u003e}} 呈现的输出效果如下： 需要注意的是，这两个 shortcodes 并不能单独使用，并且必须使用命名参数来设置它们的属性。 如果你将 LRC 放置于 audio shortcode 之中，它会通过 JS 字符串方式传递给 APlayer，所以你需要将 lrcType 设置为 1。如果你通过配置 lrc 参数的方式来设置 LRC 文件的链接，那么它将会被通过 LRC 文件方式传递给 APlayer，则 lrcType 需要被设置为 3。 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:9:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#aplayer-and-audio"},{"categories":["documentation"],"content":" 28 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: code https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: markdown {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: code https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: markdown {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:10:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#bilibili"},{"categories":["documentation"],"content":" 28.1 高级用法bilibili shortcode 支持此博客文章中展示的所有命名参数。 以下是所有命名参数的列表： 参数名 参数位置 参数用途 使用方法 id 0 视频BVID，必须项 BV1TJ411C7An p 1 视频分P（默认为1） 输入数字 autoplay 2 是否自动播放（默认为否） 1或true：启用，0或false：关闭 danmaku 3 默认弹幕开关（默认为开启） 1或true：启用，0或false：关闭 muted 4 是否默认静音（默认为否） 1或true：启用，0或false：关闭 t 5 默认开始时间（默认为0） 直接输入数值，单位为秒 以下选项目前似乎不起作用，但仍然被加进shortcode中，以希望未来这些选项能够被正常使用： 参数名 参数位置 参数用途 使用方法 hasMuteButton 6 一键静音按钮是否显示（默认不显示） 1或true：启用，0或false：关闭 hideCoverInfo 7 视频封面下方是否显示播放量弹幕量等信息（默认显示） 1或true：启用，0或false：关闭 hideDanmakuButton 8 是否隐藏弹幕按钮（默认不隐藏） 1或true：启用，0或false：关闭 noFullScreenButton 9 是否隐藏全屏按钮（默认显示） 1或true：启用，0或false：关闭 fjw 10 是否启用记忆播放（默认开启） 1或true：启用，0或false：关闭 一个带有所有命名参数的bilibili示例： markdown {{\u003c bilibili BV1TJ411C7An 3 0 0 1 30 0 1 1 1 1 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 autoplay=0 danmaku=0 muted=1 t=30 hasMuteButton=0 hideCoverInfo=1 hideDanmakuButton=1 noFullScreenButton=1 fjw=1 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:10:1","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#高级用法"},{"categories":["documentation"],"content":" 29 typeittypeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#typeit"},{"categories":["documentation"],"content":" 29.1 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: markdown {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: markdown {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:1","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#simple-content"},{"categories":["documentation"],"content":" 29.1 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: markdown {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: markdown {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:1","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#id-94"},{"categories":["documentation"],"content":" 29.2 代码内容代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: markdown {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:2","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#code-content"},{"categories":["documentation"],"content":" 29.3 分组内容默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: markdown {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:3","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#code-content"},{"categories":["documentation"],"content":" 30 script script shortcode 用来在你的文章中插入 Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: markdown {{\u003c script \u003e}} console.log('Just DoIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:12:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#script"},{"categories":["documentation"],"content":" 31 friend friend shortcode 用来在你的页面上插入友链. friend shortcode 有以下命名参数: name [必需] (第一个位置参数) 友站的名称. url [必需] (第二个位置参数) 友站的链接. avatar [必需] (第三个位置参数) 友站的头像. bio [必需] (第四个位置参数) 友站的简介. 一个 friend 示例: markdown {{\u003c friend \"PCloud\" \"https://github.com/HEIGE-PCloud/\" \"https://avatars.githubusercontent.com/u/52968553?v=4\" \"This is PCloud~💤\" \u003e}} 或者 {{\u003c friend name=\"PCloud\" url=\"https://github.com/HEIGE-PCloud/\" avatar=\"https://avatars.githubusercontent.com/u/52968553?v=4\" bio=\"This is PCloud~💤\" \u003e}} 呈现的输出效果如下: PCloud This is PCloud~💤 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:13:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#friend"},{"categories":["documentation"],"content":" 32 showcase showcase 用于在页面上插入一个个人项目的展示柜. showcase shortcode 有以下命名参数: title [required] (第一个位置参数) 项目名称. summary [required] (第二个位置参数) 项目简介. image [required] (第三个位置参数) 预览图的链接. link [required] (第四个位置参数) 项目主页的链接. column [optional] (fifth positional parameter) 这个参数定义一行显示几个 showcase. 默认的值是 2, 默认一行显示两个 showcase. 你可以将它改为 1, 2 或 3. 需要注意的是, 当用户使用小屏幕访问网站时, 每行显示的 showcase 数量将会被自动调整以保证最好的体验. 一个 showcase 示例: markdown {{\u003c showcase title=\"Theme Documentation - Basics\" summary=\"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" image=\"/theme-documentation-basics/featured-image.webp\" link=\"/theme-documentation-basics\" \u003e}} Or {{\u003c showcase \"Theme Documentation - Basics\" \"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" \"/theme-documentation-basics/featured-image.webp\" \"/theme-documentation-basics\" \u003e}} 呈现的输出效果如下: 主题文档 - 基本概念 探索 Hugo - DoIt 主题的全部内容和背后的核心概念. 阅读全文 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:14:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#showcase"},{"categories":["documentation"],"content":" 33 tabs 和 tabtabs 和 tab 是两个 shortcodes, 当一起使用时, 可以为你的内容创建一个选项卡组件。 一个 tabs 和 tab 示例: markdown {{\u003c tabs \u003e}} {{% tab title=\"选项卡 1\" %}} ### 标题 1 你好👋 #### 标题 2 ```py print(\"Hello world!\") ``` {{% /tab %}} {{% tab title=\"选项卡 2\" %}} 另一个选项卡 {{% /tab %}} {{\u003c /tabs \u003e}} 呈现的输出效果如下： 选项卡 1 选项卡 2 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:15:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#tabs-和-tab"},{"categories":["documentation"],"content":" 36.1 标题 1你好👋 36.1.1 标题 2 py print(\"Hello world!\") 另一个选项卡 由于 Hugo shortcode 系统的限制，嵌套的选项卡可能无法正常工作。 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:15:1","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#标题-1"},{"categories":["documentation"],"content":" 36.1 标题 1你好👋 36.1.1 标题 2 py print(\"Hello world!\") 另一个选项卡 由于 Hugo shortcode 系统的限制，嵌套的选项卡可能无法正常工作。 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:15:1","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#标题-2"},{"categories":["documentation"],"content":" 34 fa-iconfa-icon shortcode 用于插入 Font Awesome 5 图标。 一个 fa-icon 示例: markdown {{\u003c fa-icon regular smile \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:16:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#fa-icon"},{"categories":["documentation"],"content":" 35 personperson shortcode 用来在你的文章中以 h-card 的格式插入个人网站链接。 person shortcode 有以下命名参数： url [必需] (第一个位置参数) 个人网站的链接。 name [必需] (第二个位置参数) 个人的名字。 text [可选] (第三个位置参数) 个人的简介。 picture [可选] (第四个位置参数) 个人的头像。 nick [可选] 个人的昵称。 一个 person 示例: markdown {{\u003c person url=\"https://evgenykuznetsov.org\" name=\"Evgeny Kuznetsov\" nick=\"nekr0z\" text=\"author of this shortcode\" picture=\"https://evgenykuznetsov.org/img/avatar.jpg\" \u003e}} 呈现的输出效果为   Evgeny Kuznetsov (nekr0z). 一个使用通用图标的 person 示例: markdown {{\u003c person \"https://dillonzq.com/\" Dillon \"author of the LoveIt theme\" \u003e}} 呈现的输出效果为  Dillon. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:17:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#person"},{"categories":["documentation"],"content":" 36 blueskybluesky shortcode 用于嵌入 Bluesky 的帖子。 bluesky shortcode 有以下命名参数： link [必需] Bluesky 帖子的 URL。 一个 bluesky 示例: markdown {{\u003c bluesky link=\"https://bsky.app/profile/bsky.app/post/3latotljnec2h\" \u003e}} ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:18:0","series":["getting-start"],"tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#bluesky"},{"categories":["documentation"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["documentation"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 DoIt 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧 将此页保存为书签, 以备将来参考! ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#"},{"categories":["documentation"],"content":" 14 标题从 h2 到 h6 的标题在每个级别上都加上一个 ＃: markdown ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: html \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: markdown ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: html \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#标题"},{"categories":["documentation"],"content":" 15 注释注释是和 HTML 兼容的： html \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#注释"},{"categories":["documentation"],"content":" 16 水平线HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#水平线"},{"categories":["documentation"],"content":" 17 段落按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: markdown Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: html \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#段落"},{"categories":["documentation"],"content":" 18 内联 HTML 元素如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: html Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#内联-html-元素"},{"categories":["documentation"],"content":" 19 强调","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#强调"},{"categories":["documentation"],"content":" 19.1 加粗用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. markdown **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: html \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#加粗"},{"categories":["documentation"],"content":" 19.2 斜体用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. markdown *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: html \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#斜体"},{"categories":["documentation"],"content":" 19.3 删除线按照 GFMGitHub flavored Markdown 你可以使用删除线. markdown ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: html \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#删除线"},{"categories":["documentation"],"content":" 19.4 组合加粗, 斜体, 和删除线可以 组合使用. markdown ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: html \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#组合"},{"categories":["documentation"],"content":" 20 引用用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: markdown \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: html \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: markdown \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#引用"},{"categories":["documentation"],"content":" 21 列表","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#列表"},{"categories":["documentation"],"content":" 21.1 无序列表一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: markdown * 一项内容 - 一项内容 + 一项内容 例如: markdown * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: html \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#无序列表"},{"categories":["documentation"],"content":" 21.2 有序列表一系列项的列表, 其中项的顺序确实很重要. markdown 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: html \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: markdown 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#有序列表"},{"categories":["documentation"],"content":" 21.3 任务列表任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框, 请在方括号之间添加 x ([x]). markdown - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#任务列表"},{"categories":["documentation"],"content":" 22 代码","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#代码"},{"categories":["documentation"],"content":" 22.1 行内代码用 ` 包装行内代码段. markdown 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: html \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#行内代码"},{"categories":["documentation"],"content":" 22.2 缩进代码将几行代码缩进至少四个空格, 例如: markdown // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: html \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#缩进代码"},{"categories":["documentation"],"content":" 22.3 围栏代码块使用 “围栏” ``` 来生成一段带有语言属性的代码块. markdown ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: html \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#围栏代码块"},{"categories":["documentation"],"content":" 22.4 语法高亮GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它, 只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: markdown ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 您可以通过以下选项来自定义你的代码块： 选项 描述 类型 open 是否展开代码块。默认值由 maxShownLines 决定。 bool lineNos 是否显示行数。 int wrap 长度溢出时是否换行。 bool title 自定义代码块的标题。 string header 是否显示标题与控制按钮。 bool 以下是一个例子： markdown ```go {open=true, lineNos=false, wrap=true, header=false, title=\"main.go\"} package main import \"fmt\" // calculateSquares calculates the sum of the squares of the digits of the given number // and sends the result to the squareop channel. func calculateSquares(number int, squareop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit number /= 10 } squareop \u003c- sum } // calculateCubes calculates the sum of the cubes of the digits of the given number // and sends the result to the cubeop channel. func calculateCubes(number int, cubeop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit * digit number /= 10 } cubeop \u003c- sum } func main() { number := 589 sqrch := make(chan int) cubech := make(chan int) // Start two goroutines to calculate the sum of squares and cubes of the digits. go calculateSquares(number, sqrch) go calculateCubes(number, cubech) // Receive the results from the channels and add them. squares, cubes := \u003c-sqrch, \u003c-cubech fmt.Println(\"Final result\", squares+cubes) } ``` 输出的效果如下： main.go package main import \"fmt\" // calculateSquares calculates the sum of the squares of the digits of the given number // and sends the result to the squareop channel. func calculateSquares(number int, squareop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit number /= 10 } squareop \u003c- sum } // calculateCubes calculates the sum of the cubes of the digits of the given number // and sends the result to the cubeop channel. func calculateCubes(number int, cubeop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit * digit number /= 10 } cubeop \u003c- sum } func main() { number := 589 sqrch := make(chan int) cubech := make(chan int) // Start two goroutines to calculate the sum of squares and cubes of the digits. go calculateSquares(number, sqrch) go calculateCubes(number, cubech) // Receive the results from the channels and add them. squares, cubes := \u003c-sqrch, \u003c-cubech fmt.Println(\"Final result\", squares+cubes) } ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#语法高亮"},{"categories":["documentation"],"content":" 23 表格通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. markdown | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: html \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. markdown | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#表格"},{"categories":["documentation"],"content":" 24 链接","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#links"},{"categories":["documentation"],"content":" 24.1 基本链接 markdown \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上, 没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: html \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#基本链接"},{"categories":["documentation"],"content":" 24.2 添加一个标题 markdown [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上, 会有一行提示): Upstage 输出的 HTML 看起来像这样: html \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#添加一个标题"},{"categories":["documentation"],"content":" 24.3 定位标记定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: markdown ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: markdown ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#定位标记"},{"categories":["documentation"],"content":" 25 脚注脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. markdown 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#脚注"},{"categories":["documentation"],"content":" 26 图片图片的语法与链接相似, 但包含一个在前面的感叹号. markdown ![Minion](https://octodex.github.com/images/minion.png) 或者: markdown ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: markdown ![Alt text][id] The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: markdown [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 DoIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","series":null,"tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#图片"},{"categories":["documentation"],"content":"Hugo 和 DoIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/emoji-support/","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["documentation"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾, 并且包含 emoji 的 代码: markdown 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/emoji-support/:0:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#"},{"categories":["documentation"],"content":" 10 表情与情感","date":"2019-10-01","objectID":"/emoji-support/:1:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#表情与情感"},{"categories":["documentation"],"content":" 10.1 笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/emoji-support/:1:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#笑脸表情"},{"categories":["documentation"],"content":" 10.2 爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/emoji-support/:1:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#爱意表情"},{"categories":["documentation"],"content":" 10.3 吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/emoji-support/:1:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#吐舌头表情"},{"categories":["documentation"],"content":" 10.4 带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/emoji-support/:1:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#带手的表情"},{"categories":["documentation"],"content":" 10.5 中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/emoji-support/:1:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#中性表情"},{"categories":["documentation"],"content":" 10.6 困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/emoji-support/:1:6","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#困倦的表情"},{"categories":["documentation"],"content":" 10.7 不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/emoji-support/:1:7","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#不适的表情"},{"categories":["documentation"],"content":" 10.8 戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/emoji-support/:1:8","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#戴帽子的表情"},{"categories":["documentation"],"content":" 10.9 戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/emoji-support/:1:9","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#戴眼镜的表情"},{"categories":["documentation"],"content":" 10.10 担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹️ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/emoji-support/:1:10","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#担心的表情"},{"categories":["documentation"],"content":" 10.11 否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/emoji-support/:1:11","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#否定的表情"},{"categories":["documentation"],"content":" 10.12 特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/emoji-support/:1:12","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#特殊打扮的表情"},{"categories":["documentation"],"content":" 10.13 猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/emoji-support/:1:13","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#猫脸表情"},{"categories":["documentation"],"content":" 10.14 猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/emoji-support/:1:14","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#猴脸表情"},{"categories":["documentation"],"content":" 10.15 情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/emoji-support/:1:15","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#情感"},{"categories":["documentation"],"content":" 11 人与身体","date":"2019-10-01","objectID":"/emoji-support/:2:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人与身体"},{"categories":["documentation"],"content":" 11.1 张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/emoji-support/:2:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#张开手掌的手势"},{"categories":["documentation"],"content":" 11.2 部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/emoji-support/:2:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#部分手指的手势"},{"categories":["documentation"],"content":" 11.3 一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/emoji-support/:2:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#一根手指的手势"},{"categories":["documentation"],"content":" 11.4 握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/emoji-support/:2:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#握紧的手势"},{"categories":["documentation"],"content":" 11.5 两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/emoji-support/:2:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#两只手"},{"categories":["documentation"],"content":" 11.6 握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/emoji-support/:2:6","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#握住东西的手势"},{"categories":["documentation"],"content":" 11.7 身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/emoji-support/:2:7","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#身体部位"},{"categories":["documentation"],"content":" 11.8 人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:8","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人"},{"categories":["documentation"],"content":" 11.9 身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man :person_with_pouting_face: person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁 information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋 raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇 bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/emoji-support/:2:9","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#身体动作"},{"categories":["documentation"],"content":" 11.10 人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮 cop policeman 👮‍♀️ policewoman 🕵️ detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷 construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰‍♀️ bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/emoji-support/:2:10","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人物角色"},{"categories":["documentation"],"content":" 11.11 幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/emoji-support/:2:11","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#幻想的人物"},{"categories":["documentation"],"content":" 11.12 人物活动 图标 代码 图标 代码 💆 massage massage_woman 💆‍♂️ massage_man 💇 haircut haircut_woman 💇‍♂️ haircut_man 🚶 walking walking_man 🚶‍♀️ walking_woman 🏃 runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯 dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/emoji-support/:2:12","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人物活动"},{"categories":["documentation"],"content":" 11.13 体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄 surfer surfing_man 🏄‍♀️ surfing_woman 🚣 rowboat rowing_man 🚣‍♀️ rowing_woman 🏊 swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴 bicyclist biking_man 🚴‍♀️ biking_woman 🚵 mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/emoji-support/:2:13","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#体育"},{"categories":["documentation"],"content":" 11.14 休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/emoji-support/:2:14","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#休息"},{"categories":["documentation"],"content":" 11.15 家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👪 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/emoji-support/:2:15","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#家庭"},{"categories":["documentation"],"content":" 11.16 人物符号 图标 代码 图标 代码 🗣️ speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/emoji-support/:2:16","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人物符号"},{"categories":["documentation"],"content":" 12 动物与自然","date":"2019-10-01","objectID":"/emoji-support/:3:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#动物与自然"},{"categories":["documentation"],"content":" 12.1 哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/emoji-support/:3:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#哺乳动物"},{"categories":["documentation"],"content":" 12.2 鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊️ dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/emoji-support/:3:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#鸟类"},{"categories":["documentation"],"content":" 12.3 两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/emoji-support/:3:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#两栖动物"},{"categories":["documentation"],"content":" 12.4 爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/emoji-support/:3:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#爬虫类"},{"categories":["documentation"],"content":" 12.5 海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/emoji-support/:3:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#海洋动物"},{"categories":["documentation"],"content":" 12.6 虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/emoji-support/:3:6","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#虫类"},{"categories":["documentation"],"content":" 12.7 花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/emoji-support/:3:7","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#花类植物"},{"categories":["documentation"],"content":" 12.8 其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/emoji-support/:3:8","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它植物"},{"categories":["documentation"],"content":" 13 食物与饮料","date":"2019-10-01","objectID":"/emoji-support/:4:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#食物与饮料"},{"categories":["documentation"],"content":" 13.1 水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/emoji-support/:4:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#水果"},{"categories":["documentation"],"content":" 13.2 蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/emoji-support/:4:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#蔬菜"},{"categories":["documentation"],"content":" 13.3 快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/emoji-support/:4:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#快餐"},{"categories":["documentation"],"content":" 13.4 亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/emoji-support/:4:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#亚洲食物"},{"categories":["documentation"],"content":" 13.5 海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/emoji-support/:4:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#海鲜"},{"categories":["documentation"],"content":" 13.6 甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/emoji-support/:4:6","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#甜点"},{"categories":["documentation"],"content":" 13.7 饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/emoji-support/:4:7","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#饮料"},{"categories":["documentation"],"content":" 13.8 餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/emoji-support/:4:8","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#餐具"},{"categories":["documentation"],"content":" 14 旅游与地理","date":"2019-10-01","objectID":"/emoji-support/:5:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#旅游与地理"},{"categories":["documentation"],"content":" 14.1 地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/emoji-support/:5:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#地图"},{"categories":["documentation"],"content":" 14.2 地理现象 图标 代码 图标 代码 🏔️ mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping 🏖️ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/emoji-support/:5:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#地理现象"},{"categories":["documentation"],"content":" 14.3 建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘️ houses 🏚️ derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/emoji-support/:5:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#建筑物"},{"categories":["documentation"],"content":" 14.4 宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/emoji-support/:5:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#宗教建筑"},{"categories":["documentation"],"content":" 14.5 其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/emoji-support/:5:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它地点"},{"categories":["documentation"],"content":" 14.6 陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍️ motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/emoji-support/:5:6","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#陆路运输"},{"categories":["documentation"],"content":" 14.7 水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/emoji-support/:5:7","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#水路运输"},{"categories":["documentation"],"content":" 14.8 空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/emoji-support/:5:8","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#空中运输"},{"categories":["documentation"],"content":" 14.9 旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/emoji-support/:5:9","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#旅馆"},{"categories":["documentation"],"content":" 14.10 时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/emoji-support/:5:10","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#时间"},{"categories":["documentation"],"content":" 14.11 天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈️ cloud_with_lightning_and_rain 🌤️ sun_behind_small_cloud 🌥️ sun_behind_large_cloud 🌦️ sun_behind_rain_cloud 🌧️ cloud_with_rain 🌨️ cloud_with_snow 🌩️ cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬️ wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☔ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ⛄ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/emoji-support/:5:11","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#天空与天气"},{"categories":["documentation"],"content":" 15 活动","date":"2019-10-01","objectID":"/emoji-support/:6:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#活动"},{"categories":["documentation"],"content":" 15.1 事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟️ tickets 🎫 ticket ","date":"2019-10-01","objectID":"/emoji-support/:6:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#事件"},{"categories":["documentation"],"content":" 15.2 奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/emoji-support/:6:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#奖杯与奖牌"},{"categories":["documentation"],"content":" 15.3 体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/emoji-support/:6:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#体育运动"},{"categories":["documentation"],"content":" 15.4 游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/emoji-support/:6:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#游戏"},{"categories":["documentation"],"content":" 15.5 艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼️ framed_picture 🎨 art ","date":"2019-10-01","objectID":"/emoji-support/:6:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#艺术与工艺"},{"categories":["documentation"],"content":" 16 物品","date":"2019-10-01","objectID":"/emoji-support/:7:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#物品"},{"categories":["documentation"],"content":" 16.1 服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/emoji-support/:7:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#服装"},{"categories":["documentation"],"content":" 16.2 声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/emoji-support/:7:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#声音"},{"categories":["documentation"],"content":" 16.3 音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/emoji-support/:7:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#音乐"},{"categories":["documentation"],"content":" 16.4 乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/emoji-support/:7:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#乐器"},{"categories":["documentation"],"content":" 16.5 电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/emoji-support/:7:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#电话"},{"categories":["documentation"],"content":" 16.6 电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱️ computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/emoji-support/:7:6","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#电脑"},{"categories":["documentation"],"content":" 16.7 灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/emoji-support/:7:7","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#灯光与影像"},{"categories":["documentation"],"content":" 16.8 书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/emoji-support/:7:8","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#书与纸张"},{"categories":["documentation"],"content":" 16.9 钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/emoji-support/:7:9","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#钱"},{"categories":["documentation"],"content":" 16.10 邮件 图标 代码 图标 代码 📧 email envelope 📧 :e-mail: 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳️ ballot_box ","date":"2019-10-01","objectID":"/emoji-support/:7:10","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#邮件"},{"categories":["documentation"],"content":" 16.11 书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋️ fountain_pen 🖊️ pen 🖌️ paintbrush 🖍️ crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/emoji-support/:7:11","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#书写"},{"categories":["documentation"],"content":" 16.12 办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒️ spiral_notepad 🗓️ spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇️ paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/emoji-support/:7:12","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#办公"},{"categories":["documentation"],"content":" 16.13 锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/emoji-support/:7:13","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#锁"},{"categories":["documentation"],"content":" 16.14 工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡️ dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜️ clamp ⚖️ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/emoji-support/:7:14","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#工具"},{"categories":["documentation"],"content":" 16.15 科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 📡 satellite ","date":"2019-10-01","objectID":"/emoji-support/:7:15","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#科学"},{"categories":["documentation"],"content":" 16.16 医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/emoji-support/:7:16","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#医疗"},{"categories":["documentation"],"content":" 16.17 生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/emoji-support/:7:17","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#生活用品"},{"categories":["documentation"],"content":" 16.18 其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/emoji-support/:7:18","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它物品"},{"categories":["documentation"],"content":" 17 符号","date":"2019-10-01","objectID":"/emoji-support/:8:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#符号"},{"categories":["documentation"],"content":" 17.1 交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/emoji-support/:8:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#交通标识"},{"categories":["documentation"],"content":" 17.2 警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 :non-potable_water: 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢️ radioactive ☣️ biohazard ","date":"2019-10-01","objectID":"/emoji-support/:8:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#警告"},{"categories":["documentation"],"content":" 17.3 箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/emoji-support/:8:3","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#箭头"},{"categories":["documentation"],"content":" 17.4 宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉️ om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/emoji-support/:8:4","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#宗教"},{"categories":["documentation"],"content":" 17.5 生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/emoji-support/:8:5","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#生肖"},{"categories":["documentation"],"content":" 17.6 影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭️ next_track_button ⏯️ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸️ pause_button ⏹️ stop_button ⏺️ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/emoji-support/:8:6","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#影像符号"},{"categories":["documentation"],"content":" 17.7 数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:7","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#数学"},{"categories":["documentation"],"content":" 17.8 标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/emoji-support/:8:8","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#标点符号"},{"categories":["documentation"],"content":" 17.9 货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/emoji-support/:8:9","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#货币"},{"categories":["documentation"],"content":" 17.10 按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/emoji-support/:8:10","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#按键符号"},{"categories":["documentation"],"content":" 17.11 字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id Ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/emoji-support/:8:11","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#字母符号"},{"categories":["documentation"],"content":" 17.12 几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/emoji-support/:8:12","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#几何符号"},{"categories":["documentation"],"content":" 17.13 其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/emoji-support/:8:13","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它符合"},{"categories":["documentation"],"content":" 18 旗帜","date":"2019-10-01","objectID":"/emoji-support/:9:0","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#旗帜"},{"categories":["documentation"],"content":" 18.1 常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳️ white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/emoji-support/:9:1","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#常用旗帜"},{"categories":["documentation"],"content":" 18.2 国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/emoji-support/:9:2","series":null,"tags":["emoji"],"title":"Emoji 支持","uri":"/emoji-support/#国家和地区旗帜"},{"categories":["Documentation"],"content":"Guide to setup PWA in DoIt","date":"2021-05-10","objectID":"/pwa-support/","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/"},{"categories":["Documentation"],"content":"了解如何在 DoIt 主题中配置渐进式网络应用程序 (PWA). ","date":"2021-05-10","objectID":"/pwa-support/:0:0","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#"},{"categories":["Documentation"],"content":" 1 什么是 PWA？渐进式网络应用程序(PWA)是运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台网络应用程序.这些应用无处不在、功能丰富, 使其具有与原生应用相同的用户体验. ","date":"2021-05-10","objectID":"/pwa-support/:1:0","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#什么是-pwa"},{"categories":["Documentation"],"content":" 2 为什么要配置 PWA？你并不需要将你的站点配置为一个 PWA. 传统的网站足以满足你想要分享的所有内容.但是, PWA 带来了一些可能有用的额外好处. 在用户安装 PWA 后, 页面将由 service worker 自动缓存, 这使得从第二次访问开始页面将被快速加载. 用户始终可以在离线时访问缓存的页面. 这些功能可能对某些网站（例如此文档站点）很有用, 但是将个人博客配置为 PWA 就没有多少意义.当然一切都取决于你的选择, 无论如何 DoIt 主题都将为你提供开启此功能的选项. ","date":"2021-05-10","objectID":"/pwa-support/:2:0","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#为什么要配置-pwa"},{"categories":["Documentation"],"content":" 3 如何将使用 DoIt 主题的静态网站配置为 PWA?","date":"2021-05-10","objectID":"/pwa-support/:3:0","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#如何将使用-doit-主题的静态网站配置为-pwa"},{"categories":["Documentation"],"content":" 3.1 配置 site.webmanifest你需要在 /static 文件夹下创建名为 site.webmanifest 的文件, 并在此文件提供有关你的 PWA 的信息. 以下是必填参数. name [必须] 你的 PWA 的名称. short_name [必须] 你的 PWA 的简称. start_url [必须] 你的 PWA 的起始地址.请默认填写\"/\". icons [必须] 你的 PWA 的图标.你可以将网站的 favicon 作为图标. 您还可以在 site.webmanifest 中设置其他可选值, 查看这篇文档来了解更多. 这是一份示例 site.webmanifest 文件. json { \"name\": \"DoIt Theme Documentation\", \"short_name\": \"DoIt Docs\", \"start_url\": \"/\", \"description\": \"The documentation site for Hugo DoIt Theme\", \"theme_color\": \"#ffffff\", \"background_color\": \"#ffffff\", \"orientation\": \"portrait\", \"display\": \"standalone\", \"icons\": [ { \"src\": \"/android-chrome-192x192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" }, { \"src\": \"/android-chrome-512x512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" }, { \"src\": \"/apple-touch-icon.png\", \"sizes\": \"180x180\", \"type\": \"image/png\", \"purpose\": \"any maskable\" } ] } ","date":"2021-05-10","objectID":"/pwa-support/:3:1","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#配置-sitewebmanifest"},{"categories":["Documentation"],"content":" 3.2 配置离线页面离线页面将在访客离线访问未缓存的页面时显示. 在/content目录下创建offline.md并在其中编写离线提示. Permalink 你需要确保离线页面的 Permalink 是 /offline, 否则你需要手动更改 service worker 中 OFFLINE_CACHE_FILES 和 OFFLINE_PAGE 的值. i18n 目前离线页面不支持 i18n, 如果你运行的是多语言网站, 请考虑在同一页面上编写多条不同语言的离线消息. 这是一个示例离线页面. md --- title: \"Offline\" --- \u003e 你没有连接至互联网, 只有缓存的页面可用. ","date":"2021-05-10","objectID":"/pwa-support/:3:2","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#配置离线页面"},{"categories":["Documentation"],"content":" 3.3 开启 enablePWA 选项前往 config.toml, 添加/修改 [params] 配置项下 enablePWA 选项的值为 true. toml [params] # ... enablePWA = true ","date":"2021-05-10","objectID":"/pwa-support/:3:3","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#开启-enablepwa-选项"},{"categories":["Documentation"],"content":" 4 安装并使用你的 PWA如果一切顺利, 现在当你访问你的网站时, 浏览器将显示一个安装按钮. 安装 PWA 单击“安装”后, 你的网站将被安装为一个本地的原生应用程序. 安装完成 大功告成！你已成功将你的静态网站配置为了一个 PWA 🎉 如果你在配置过程中有任何问题, 你可以通过浏览器调试工具中的 Console 与 Application 面板来进行调试.你也可以用PWA Builder来检查你的网站以获得更多信息.你可以创建一个 discussion 来获得社区帮助或者提交 issue 来报告你遇到的任何 bug. ","date":"2021-05-10","objectID":"/pwa-support/:4:0","series":null,"tags":["PWA"],"title":"PWA 支持","uri":"/pwa-support/#安装并使用你的-pwa"},{"categories":["Documentation"],"content":"这篇文档将展示如何在 DoIt 中使用 GoAT 和 Mermaid 创建 SVG 图表。","date":"2022-02-28","objectID":"/create-diagrams/","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/"},{"categories":["Documentation"],"content":" Note 你需要使用 Hugo v0.93.0 或更新的版本来创建自定义图表。 如果你不得不使用旧版的 Hugo，你可以使用 mermaid shortcode。 ","date":"2022-02-28","objectID":"/create-diagrams/:0:0","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#"},{"categories":["Documentation"],"content":" 3 GoATGoATGo ASCII Tool 是 markdeep.mini.js 图像生成器的 Go 语言实现。 要使用 GoAT，只需将 ASCII 输入放在代码块中，并将语言设置为 goat。 markdown ```goat // ASCII input here ``` 以下是使用 GoAT 生成 SVG 的一些示例。 查看更多示例 。 ","date":"2022-02-28","objectID":"/create-diagrams/:1:0","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#goat"},{"categories":["Documentation"],"content":" 3.1 树 markdown ```goat . . . .--- 1 .-- 1 / 1 / \\ | | .---+ .-+ + / \\ .---+---. .--+--. | '--- 2 | '-- 2 / \\ 2 + + | | | | ---+ ---+ + / \\ / \\ .-+-. .-+-. .+. .+. | .--- 3 | .-- 3 \\ / 3 / \\ / \\ | | | | | | | | '---+ '-+ + 1 2 3 4 1 2 3 4 1 2 3 4 '--- 4 '-- 4 \\ 4 ``` 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 ","date":"2022-02-28","objectID":"/create-diagrams/:1:1","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#树"},{"categories":["Documentation"],"content":" 3.2 重叠 markdown ```goat .-. .-. .-. .-. .-. .-. | | | | | | | | | | | | .---------. .--+---+--. .--+---+--. .--| |--. .--+ +--. .------|--. | | | | | | | | | | | | | | | | | | '---------' '--+---+--' '--+---+--' '--| |--' '--+ +--' '--|------' | | | | | | | | | | | | '-' '-' '-' '-' '-' '-' ``` ","date":"2022-02-28","objectID":"/create-diagrams/:1:2","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#重叠"},{"categories":["Documentation"],"content":" 3.3 线条装饰 markdown ```goat ________ o * * .--------------. *---+--. | | o o | ^ \\ / | .----------. | | | '--* -+- | | v / \\ / | | \u003c------. | | | '-----\u003e .---(---' ---\u003e*\u003c--- / .+-\u003e*\u003c--o----' | | | | | \u003c--' ^ ^ | | | | | ^ \\ | '--------' | | \\/ *-----' o |\u003c-----\u003e| '-----' |__| v '------------' | /\\ *---------------' ``` ","date":"2022-02-28","objectID":"/create-diagrams/:1:3","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#线条装饰"},{"categories":["Documentation"],"content":" 3.4 线端 markdown ```goat o--o *--o / / * o o o o o * * * * o o o o * * * * o o o o * * * * o--* *--* v v ^ ^ | | | | | | | | \\ \\ \\ \\ \\ \\ \\ \\ / / / / / / / / o--\u003e *--\u003e * o / / o * v ' o * v ' o * v \\ o * v \\ o * v / o * v / o--- *--- ^ ^ ^ ^ . . . . ^ ^ ^ ^ \\ \\ \\ \\ ^ ^ ^ ^ / / / / | | * o \\ \\ * o | | | | | | | | \\ \\ \\ \\ \\ \\ \\ \\ / / / / / / / / v v ^ ^ v v ^ ^ o * v ' o * v ' o * v \\ o * v \\ o * v / o * v / * o | | * o \\ \\ \u003c--o \u003c--* \u003c--\u003e \u003c--- ---o ---* ---\u003e ---- *\u003c-- o\u003c-- --\u003eo --\u003e* ``` ","date":"2022-02-28","objectID":"/create-diagrams/:1:4","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#线端"},{"categories":["Documentation"],"content":" 3.5 点网格 markdown ```goat o o o o o * * * * * * * o o * o o o * * * o o o · * · · · · · · o o o o o * * * * * o o o o * o o o o * * * * * o * * · * * · · · · · · o o o o o * * * * * o * o o o o o o o o * * * * * o o o o o · o · · o · · * * · o o o o o * * * * * o * o o o o o o o * * * * o * o o · · · · o · · * · o o o o o * * * * * * * * * o o o o * * * o * o · · · · · · · * ``` · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ","date":"2022-02-28","objectID":"/create-diagrams/:1:5","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#点网格"},{"categories":["Documentation"],"content":" 3.6 大节点 markdown ```goat .---. .-. .-. .-. .-. | A +-----\u003e| 1 +\u003c----\u003e| 2 |\u003c----+ 4 +------------------. | 8 | '---' '-' '+' '-' | '-' | ^ | ^ v | v | .-. .-+-. .-. .-+-. .-. .+. .---. | 3 +----\u003e| B |\u003c-----\u003e| 5 +----\u003e| C +----\u003e| 6 +----\u003e| 7 |\u003c----\u003e| D | '-' '---' '-' '---' '-' '-' '---' ``` A 1 2 3 4 B 5 C 6 8 7 D ","date":"2022-02-28","objectID":"/create-diagrams/:1:6","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#大节点"},{"categories":["Documentation"],"content":" 3.7 小网格 markdown ```goat ___ ___ .---+---+---+---+---. .---+---+---+---. .---. .---. ___/ \\___/ \\ | | | | | | / \\ / \\ / \\ / \\ / | +---+ | / \\___/ \\___/ +---+---+---+---+---+ +---+---+---+---+ +---+ +---+ \\___/ b \\___/ \\ | | | b | | | \\ / \\a/ \\b/ \\ / \\ | +---+ | / a \\___/ \\___/ +---+---+---+---+---+ +---+---+---+---+ +---+ b +---+ \\___/ \\___/ \\ | | a | | | | / \\ / \\ / \\ / \\ / | a +---+ | \\___/ \\___/ '---+---+---+---+---' '---+---+---+---' '---' '---' ``` a b a b a b a b ","date":"2022-02-28","objectID":"/create-diagrams/:1:7","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#小网格"},{"categories":["Documentation"],"content":" 3.8 大网格 markdown ```goat .----. .----. / \\ / \\ .-----+-----+-----. + +----+ +----. | | | | .-----+-----+-----+-----+ \\ / \\ / \\ | | | | / / / / / +----+ B +----+ + +-----+-----+-----+ +-----+-----+-----+-----+ / \\ / \\ / | | | | / / / / / + A +----+ +----+ | | B | | +-----+-----+-----+-----+ \\ / \\ / \\ +-----+-----+-----+ / / A / B / / '----+ +----+ + | | | | +-----+-----+-----+-----+ \\ / \\ / | A | | | / / / / / '----' '----' '-----+-----+-----' '-----+-----+-----+-----+ ``` A B A B A B ","date":"2022-02-28","objectID":"/create-diagrams/:1:8","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#大网格"},{"categories":["Documentation"],"content":" 3.9 复杂图表 markdown ```goat +-------------------+ ^ .---. | A Box |__.--.__ __.--\u003e | .-. | | | | '--' v | * |\u003c--- | | +-------------------+ '-' | | Round *---(-. | .-----------------. .-------. .----------. .-------. | | | | Mixed Rounded | | | / Diagonals \\ | | | | | | | \u0026 Square Corners | '--. .--' / \\ |---+---| '-)-' .--------. '--+------------+-' .--. | '-------+--------' | | | | / Search / | | | | '---. | '-------' | '-+------' |\u003c----------\u003e| | | | v Interior | ^ ' \u003c---' '----' .-----------. ---. .--- v | .------------------. Diag line | .-------. +---. \\ / . | | if (a \u003e b) +---. .---\u003e| | | | | Curved line \\ / / \\ | | obj-\u003efcn() | \\ / | '-------' |\u003c--' + / \\ | '------------------' '--' '--+--------' .--. .--. | .-. +Done?+-' .---+-----. | ^ |\\ | | /| .--+ | | \\ / | | | Join \\|/ | | Curved | \\| |/ | | \\ | \\ / | | +----\u003e o --o-- '-' Vertical '--' '--' '-- '--' + .---. \u003c--+---+-----' | /|\\ | | 3 | v not:line 'quotes' .-' '---' .-. .---+--------. / A || B *bold* | ^ | | | Not a dot | \u003c---+---\u003c-- A dash--is not a line v | '-' '---------+--' / Nor/is this. --- ``` \u0026 A M S i o i q f b B x u j o e a ( - x d r a \u003e e f R \u003e c o C n u o b ( n r ) ) d n e e J d r o s i n N o R D t o i u a a n g d d l o i t n e D i a g o n a l s C V u e r r v t e i d c a l n o t A N C : o u l d r r i A a / I v n s i n e e h s t d - e - t r l B i h i i s i o n ' s r e q n . u * o o b t t o e l a s d ' * l i n e D o n S e e ? a r c 3 h ","date":"2022-02-28","objectID":"/create-diagrams/:1:9","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#复杂图表"},{"categories":["Documentation"],"content":" 4 MermaidMermaid 是一个基于 JavaScript 的图表工具，它允许您使用文本和代码创建图表和可视化。 要使用 Mermaid，只需将 Mermaid 的代码输入放在代码块中，并将语言设置为 mermaid。 markdown ```mermaid // mermaid diagram code here ``` 下面是一些使用 Mermaid 生成的 SVG 图表示例。 ","date":"2022-02-28","objectID":"/create-diagrams/:2:0","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#mermaid"},{"categories":["Documentation"],"content":" 4.1 流程图All Flowcharts are composed of nodes, geometric shapes and edges, the arrows or lines. The mermaid code defines the way that these nodes and edges are made and interact. markdown ```mermaid graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ``` graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ","date":"2022-02-28","objectID":"/create-diagrams/:2:1","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#流程图"},{"categories":["Documentation"],"content":" 4.2 序列图A Sequence diagram is an interaction diagram that shows how processes operate with one another and in what order. markdown ```mermaid sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! ``` sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! ","date":"2022-02-28","objectID":"/create-diagrams/:2:2","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#序列图"},{"categories":["Documentation"],"content":" 4.3 甘特图A Gantt chart is a type of bar chart, first developed by Karol Adamiecki in 1896, and independently by Henry Gantt in the 1910s, that illustrates a project schedule and the amount of time it would take for any one project to finish. Gantt charts illustrate numbers of days between the start and finish dates of the terminal elements and summary elements of a project. markdown ```mermaid gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ``` gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ","date":"2022-02-28","objectID":"/create-diagrams/:2:3","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#甘特图"},{"categories":["Documentation"],"content":" 4.4 类图The class diagram is the main building block of object-oriented modelling. It is used for general conceptual modelling of the structure of the application, and detailed modelling translating the models into programming code. Class diagrams can also be used for data modelling. The classes in a class diagram represent both the main elements, interactions in the application, and the classes to be programmed. markdown ```mermaid classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label ``` classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label ","date":"2022-02-28","objectID":"/create-diagrams/:2:4","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#类图"},{"categories":["Documentation"],"content":" 4.5 Git 图 markdown ```mermaid gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release ``` gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release ","date":"2022-02-28","objectID":"/create-diagrams/:2:5","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#git-图"},{"categories":["Documentation"],"content":" 4.6 实体关系图 - 实验性An entity–relationship diagram (or ER diagram) describes interrelated things of interest in a specific domain of knowledge. A basic ER diagram is composed of entity types (which classify the things of interest) and specifies relationships that can exist between entities (instances of those entity types). markdown ```mermaid erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ``` erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ","date":"2022-02-28","objectID":"/create-diagrams/:2:6","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#实体关系图---实验性"},{"categories":["Documentation"],"content":" 4.7 用户旅程图User journey diagrams describe at a high level of detail exactly what steps different users take to complete a specific task within a system, application or website. This technique shows the current (as-is) user workflow, and reveals areas of improvement for the to-be workflow. markdown ```mermaid journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ``` journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ","date":"2022-02-28","objectID":"/create-diagrams/:2:7","series":["how-to-doit"],"tags":["diagram","markdown"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#用户旅程图"},{"categories":null,"content":" 主题文档 - 基本概念 探索 Hugo - DoIt 主题的全部内容和背后的核心概念 阅读全文 主题文档 - 内容 了解如何在 DoIt 主题中快速, 直观地创建和组织内容 阅读全文 主题文档 - 扩展 Shortcodes DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode 阅读全文 ","date":"2021-11-01","objectID":"/showcase/:0:0","series":null,"tags":null,"title":"作品","uri":"/showcase/#"},{"categories":null,"content":" DoIt 是一个由 HEIGE-PCloud 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LoveIt 主题， LeaveIt 主题 和 KeepIt 主题。 ","date":"2019-08-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#"},{"categories":null,"content":" 1 特性","date":"2019-08-02","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#特性"},{"categories":null,"content":" 1.1 性能和 SEO 性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分 使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化 支持 Google Analytics 支持 Fathom Analytics 支持 百度统计 支持 Umami Analytics 支持 Plausible Analytics 支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu) 支持所有第三方库的 CDN ","date":"2019-08-02","objectID":"/about/:1:1","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#性能和-seo"},{"categories":null,"content":" 1.2 外观和布局 []/[] 响应式布局 []/[] 浅色/深色 主题模式 全局一致的设计语言 支持分页 易用和自动展开的文章目录 支持多语言和国际化 美观的 CSS 动画 ","date":"2019-08-02","objectID":"/about/:1:2","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#外观和布局"},{"categories":null,"content":" 1.3 社交和评论系统 支持 Gravatar 头像 支持本地头像 支持多达 64 种社交链接 支持多达 28 种网站分享 支持 Disqus 评论系统 支持 Gitalk 评论系统 支持 Valine 评论系统 支持 Waline 评论系统 支持 Facebook 评论系统 支持 Telegram comments 评论系统 支持 Commento 评论系统 支持 Utterances 评论系统 支持 Twikoo 评论系统 支持 Vssue 评论系统 支持 Remark42 评论系统 支持 giscus 评论系统 支持 Artalk 评论系统 ","date":"2019-08-02","objectID":"/about/:1:3","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#社交和评论系统"},{"categories":null,"content":" 1.4 扩展功能 支持基于 algolia 或 Fuse.js 的搜索 支持 Twemoji 支持代码高亮 一键复制代码到剪贴板 支持基于 lightgallery.js 的图片画廊 支持 Font Awesome 图标的扩展 Markdown 语法 支持上标注释的扩展 Markdown 语法 支持分数的扩展 Markdown 语法 支持基于 $ \\KaTeX $ 的数学公式 支持基于 mermaid 的图表 shortcode 支持基于 ECharts 的交互式数据可视化 shortcode 支持基于 Mapbox GL JS 的 Mapbox shortcode 支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode 支持 Bilibili 视频 shortcode 支持多种注释的 shortcode 支持自定义样式的 shortcode 支持自定义脚本的 shortcode 支持基于 TypeIt 的打字动画 shortcode 支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:1:4","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#扩展功能"},{"categories":null,"content":" 2 许可协议DoIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 DoIt 主题中用到了以下项目，感谢它们的作者： Font Awesome Simple Icons autocomplete.js algoliasearch Fuse.js object-fit-images Twemoji lightgallery.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine Waline Twikoo Vssue cookieconsent Remark42 ","date":"2019-08-02","objectID":"/about/:2:0","series":null,"tags":null,"title":"关于 DoIt","uri":"/about/#许可协议"}]