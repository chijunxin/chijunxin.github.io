# Epoll



<!--more-->

## 什么是epoll？
`epoll` 是 Linux 内核为处理大量并发网络连接而提出的 I/O 事件通知机制。它是 `select` 和 `poll` 的增强版，解决了它们在处理海量连接时性能低下的问题。

你可以把它想象成一个高效的“事件监听器”：你告诉它需要关心哪些文件描述符（比如网络套接字），当这些描述符就绪（例如，有数据可读、可以写入数据、或发生错误）时，它会主动通知你，从而让你能够进行非阻塞的 I/O 操作。

___

## 为什么需要 epoll？—— select/poll 的瓶颈
在 `epoll` 出现之前，程序员主要使用 `select` 或 `poll`。

1. 性能随连接数线性下降：`select` 和 `poll` 每次调用时，都需要将整个需要监听的文件描述符集合从用户空间复制到内核空间。

1. 遍历开销大：当有事件发生时，`select` 和 `poll` 返回的是整个描述符集合，应用程序需要**遍历整个集合** 来找出哪些描述符真正就绪了。当有上万个连接，但只有少数几个活跃时，这种遍历是巨大的性能浪费。

**核心问题**：`select/poll` 的处理效率与连接数 `O(n)` 成正比。

**`epoll` 的解决方案**：它的处理效率与**活跃的连接数** `O(k)` 成正比，其中 `k` 是活跃连接的数量，通常远小于总连接数 `n`。

___

## poll 的核心工作机制
`epoll` 通过三个核心的系统调用来工作：

### `epoll_create` - 创建一个 epoll 实例
``` c
int epoll_create(int size);
```

这个调用会创建一个 `epoll` 实例，并返回一个指向该实例的文件描述符。参数 `size` 在现代 Linux 内核中已不再重要（内核会动态调整），但必须大于0。使用完毕后，应通过 `close()` 关闭该描述符以释放资源。

### `epoll_ctl` - 管理兴趣列表
``` c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```
这个调用用于向 `epoll` 实例（`epfd`）的“兴趣列表”中添加、修改或删除需要监视的文件描述符（`fd`）。

* `op` : 操作类型:
  * `EPOLL_CTL_ADD`：添加一个需要监视的文件描述符。
  * `EPOLL_CTL_MOD`：修改一个已存在的文件描述符的监视事件。
  * `EPOLL_CTL_DEL`：从兴趣列表中删除一个文件描述符。
* `event`: 指向 `struct epoll_event` 的指针，告诉内核我们关心这个描述符的什么事件。

``` c
struct epoll_event {
    uint32_t     events;  /* Epoll events (bit mask) */
    epoll_data_t data;    /* User data variable */
};

// 常见的 events 取值：
// EPOLLIN   - 关联的文件描述符可读
// EPOLLOUT  - 关联的文件描述符可写
// EPOLLET   - 设置为边缘触发(Edge Triggered)模式（默认为水平触发 Level Triggered）
// EPOLLONESHOT - 一次性监视，事件发生后会自动从兴趣列表中移除
```

### `epoll_wait` - 等待事件发生
``` c
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

这是核心的等待函数。它阻塞（除非设置了超时）并等待在兴趣列表中的文件描述符上发生事件。

* `events`：一个由调用者分配的 `epoll_event` 结构数组。当有事件发生时，内核会把就绪的事件信息填充到这个数组中。
* `maxevents`：指定 `events` 数组的大小，一次调用最多返回这么多事件。
* `timeout`：超时时间（毫秒）。`-1` 表示无限阻塞，`0` 表示立即返回。

**关键优势**：`epoll_wait` 返回时，`events` 数组中包含的就是所有就绪的文件描述符信息。应用程序**无需遍历所有连接**，直接处理这些返回的事件即可，效率极高。

___

## epoll 的工作模式：LT 与 ET
`epoll` 提供了两种截然不同的工作模式，理解他们至关重要。

### 水平触发（Level-Triggered, LT）- 默认模式
* **行为**：只要文件描述符处于就绪状态（例如，读缓冲区不为空，写缓冲区未满），`epoll_wait` 就会持续通知你。
* **优点**：编程更简单，不容易遗漏事件。即使你某次没有把数据全部读完，下次调用 `epoll_wait` 时它还会再次通知你。
* **类比**：就像一个电平信号，只要处于高电平，就持续亮灯。

### 边缘触发（Edge-Triggered, ET）
* **行为**：只有当文件描述符的状态**发生变化时**（例如，从不可读变为可读，从不可写变为可写），`epoll_wait` 才会通知你一次。
* **优点**：性能更高，减少了相同事件被重复通知的次数。
* **要求**：要求应用程序必须**一次性地**把数据读完或写完，直到系统调用（如 `read`, `write`）返回 `EAGAIN` 或 `EWOULDBLOCK` 错误为止。否则，由于没有新的状态变化，即使缓冲区里还有数据，你也不会再收到通知。
* **使用方法**：在 events 字段中设置 EPOLLET 标志。
* **类比**：就像一个边沿信号，只有在上升沿或下降沿的瞬间触发一次。

{{< admonition info "简单对比" >}}
* LT：epoll 问：“这个 socket 可以读吗？” 如果可以，它会一直提醒你，直到你读完。
* ET：epoll 说：“注意！这个 socket 刚刚有数据来了（状态变了）！” 只提醒一次，读不读完是你的事。
{{< /admonition >}}

___

## 使用 epoll 的基本流程（服务器端示例）
1. socket(), bind(), listen() 创建监听套接字。

2. epoll_create() 创建一个 epoll 实例。

3. 将监听套接字通过 epoll_ctl(..., EPOLL_CTL_ADD, ...) 添加到 epoll 的兴趣列表中，监视 EPOLLIN 事件。

4. 进入一个无限循环：
    1. 调用 epoll_wait() 等待事件。
    2. 遍历返回的 events 数组：

    * 如果是监听套接字就绪，说明有新连接。调用 accept()，并将新的客户端套接字也添加到 epoll 的兴趣列表中（通常设置为非阻塞模式，特别是使用 ET 模式时）。

    * 如果是客户端套接字就绪，并且事件是 EPOLLIN，则调用 read() 读取数据。如果使用 ET 模式，必须循环读取直到 EAGAIN。

    * 如果是 EPOLLOUT 事件，则可以写入数据。

5. 在处理过程中，如果客户端断开连接，则通过 epoll_ctl(..., EPOLL_CTL_DEL, ...) 将其从兴趣列表中移除，并关闭套接字。


## 总结


| 特性           |  select / poll            |      epoll
| :--------      |  :----------              |   :-----------            
| 效率           |  连接数线性 O(n)          |  活跃连接数线性 O(k)
| 大量连接       |  性能急剧下降             |   性能优异，可支持数十万并发连接
| 工作模式	     |  仅支持 LT                |  支持 LT 和 ET
| 内核与用户空间 |  每次调用都复制整个fd集合   |    使用内存映射(mmap)，只需一次添加
| 编程复杂性     |  简单                     |  相对复杂，尤其是 ET 模式


{{< admonition tip "适用场景：" >}}
`epoll` 非常适合需要处理**大量并发连接**，但其中只有**少数是活跃连接**的网络服务器，例如现代的高性能 Web 服务器（Nginx）、网关、实时通信系统等。对于连接数较少的情况，`select` 或 `poll` 可能更简单实用。
{{< /admonition >}}

